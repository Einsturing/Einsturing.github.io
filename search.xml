<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[第2章 应用层]]></title>
    <url>%2F2019%2F06%2F05%2FCN2%2F</url>
    <content type="text"><![CDATA[应用层的作用是为用户的分布式应用程序提供访问网络的接口。 2.1 应用层的基本概念2.1.1 网络应用程序的体系结构网络应用程序的体系结构指在各端系统上的分布式应用程序的工作模式，由研发者决定，分为客户机/服务器模式(C/S)和对等模式(P2P)。 客户机/服务器模式：服务器通常一直运行，具有固定的IP地址，可为多个客户机提供服务，可扩展为服务器集群。客户机偶尔开机，具有固定或动态的IP地址，向服务器发出请求，客户机之间不直接通信。大部分网络应用如Web应用、电子邮件、文件传输采用该模式。 P2P模式：无(或很少使用)服务器。如果有服务器，也只用于如注册IP地址、登记用户、计费等。端系统(对等方)之间直接数据通信，既请求服务，也提供服务。对等方IP地址可以不固定。BT、QQ、Skype等采用该模式。 2.1.2 进程通信进程(process)即在主机上并行运行的程序。同一主机中的进程通信由操作系统控制，不同主机中的进程通信通过网络交换报文，发送进程产生报文，并向网络发送；接收进程接收报文，并返回响应报文。 分布式应用程序由不同进程组成，发起通信的进程为客户机(client)进程，等待通信的进程为服务器(server)进程。在P2P模式中，一个进程同时充当两角色。 网络通信实质上是不同主机进程间通信，网络中传送的分组，通常携带目的进程的识别信息。进程的识别信息分两部分。主机地址指出进程位于网络中的哪一个主机，因特网中用IP地址标识。进程标识指出进程是主机中的哪一个进程，在主机中用传输层协议和端口号标识。 端口用来在主机中区分不同的进程，针对TCP和UDP，各有一套0~65535的端口。端口分为周知端口和临时端口。周知端口有固定用途，通常用于特定的服务器进程，编号0~1023，如Web服务器进程TCP 80，邮件传输服务器进程TCP 25，DHCP服务器进程UDP 67。临时端口一般用于客户机进程，使用前由进程向本地操作系统申请，使用完毕后归还，编号1024~65535。 2.1.3 套接字套接字(socket)：位于应用层的应用程序(进程)和网络之间的应用程序接口API，位于应用层与运输层之间，用于进程向网络发送和接收报文。进程与套接字好比房子与门，每个进程通过对应的套接字在网络上发收报文。编程者设计套接字的应用层端，即进程，几乎不用控制套接字的运输层端，但可选择运输层协议，设定运输层参数。 图2-1：套接字 2.1.4 应用层协议应用层协议定义了网络进程间传递报文的格式和规则。具体有语法：各类报文的各字段结构；语义：字段信息的含义；语序：何时、如何发送报文及对报文进行响应。 网络应用所需的运输服务有可靠数据传输、吞吐量、定时和安全性。 应用程序 数据丢失 带宽 时间敏感 文件传输 不能丢失 弹性 否 电子邮件 不能丢失 弹性 否 Web文档 不能丢失 弹性 否 实时音/视频 容忍丢失 音频：5kbps~1Mbps 视频10kbps~5Mbps 是，100ms 存储音/视频 容忍丢失 同上 是，几秒 交互式游戏 容忍丢失 几kbps以上 是，100ms 即时讯息 不能丢失 弹性 是 应用层协议建立在运输层提供的服务之上。因特网的两个运输层协议TCP和UDP提供不同的进程到进程传输服务。 TCP服务是面向连接、可靠的传输服务。客户机程序和服务器程序之间交换控制信息，在两个进程的套接字之间通过网络建立一个TCP连接，通过全双工方式进行报文传输，最后拆除连接。TCP采取确认重传、流量控制、拥塞控制等措施实现进程间无差错、按顺序的数据交付。TCP能保证正确交付所有的数据，但开销较大，适合重要数据、较大数据的可靠传输。 UDP服务采用最小服务模式，进程间无握手过程，不保证报文能够被目的进程最终接收和按序接收，以当前最大速率传输，没有流量控制、拥塞控制机制，也不提供时延保证。UDP简单高效，适于普通数据、小块数据的快速传送。 应用 应用层协议 传输层协议 电子邮件 SMTP TCP 远程终端访问 Telnet TCP Web HTTP TCP 文件传输 FTP TCP 远程文件服务器 NFS UDP或TCP 流媒体 HTTP、RTP UDP或TCP 因特网电话 SIP、RTP UDP或TCP 2.2 Web应用2.2.1 HTTP概述Web应用包括客户及程序(浏览器)和服务器程序，运行在不同的端系统中，通过应用层的HTTP(Hypertext Transfer Protocol超文本传输协议)进行会话。HTTP协议定义了HTTP报文的格式以及客户机和服务器交换报文的方式。 Web页面(文档)也称网页，由若干对象文件组成，如HTML(Hypertext Markup Language 超文本标记语言)文件、JPEG图形、Java小程序等，每个对象由URL来寻址。 URL(Uniform Resource Locator)：统一资源定位符，用于标识万维网上对象资源的全网唯一的地址。 客户机程序(浏览器)：用于向服务器程序发出Web页面获取请求，并向用户显示所获取的Web页面。如IE，FireFox，Chrome等。 Web服务器程序：用于存贮Web对象(由URL寻址)，并响应客户请求。如IIS(Windows，商业软件)，Apache(跨平台，开放软件，应用最多)，TomCat(跨平台，开放软件，面向Java)。 Web应用使用客户机/服务器模式，服务器总是打开，使用固定IP地址和周知端口80，为多个浏览器服务。用户点击或输入超链接，浏览器向URL对应的服务器发出HTTP请求报文，服务器接收请求，返回包含页面(若存在)的HTTP响应报文。 HTTP基于运输层的TCP，保证HTTP报文传输的可靠性。HTTP是无状态协议，服务器不保存关于客户机的任何信息。 2.2.2 HTTP连接HTTP1.1默认使用持续连接方式，一个TCP连接上可以传送多对HTTP请求/响应报文。 持续连接方式有流水线方式(默认)和非流水线方式两种。在同一TCP连接上，非流水线方式中客户机只能在收到前一个请求的响应之后，才能发出新的请求。流水线方式中客户机连续发送请求(针对不同的Web页面)，无需等待响应。服务器连续返回此客户机请求的对象。 2.2.3 HTTP报文格式 图2-2：HTTP请求报文的格式 请求方法： GET：请求一个对象，如Web页面，此时实体为空。 POST：将实体中信息传给服务器处理，通常是用户在表单中输入的信息。 HEAD：请求一个对象的信息，而不是对象本身，实体为空。 PUT：向URL指定的服务器的位置上传对象，实体为此对象。 DELETE：删除URL指定的服务器中的对象，实体为空。 部分状态码与短语： 200 OK：请求成功，返回的对象在实体中。 301 Moved Permanently：请求的对象已转移，其新的URL在首部行的Location中给出。 400 Bad Request：错误的请求 404 Not Found：请求的对象不在该服务器上 505 HTTP Version Not Supported：请求报文的HTTP版本服务器不支持 2.2.4 用户与服务器交互：CookieHTTP服务器是无状态的，不保存客户信息；但客户端可以用cookie方式保存客户信息，允许Web应用跟踪、识别用户。许多Web站点都使用cookie，每台客户机都有很多不同网站的cookie文件。客户机中建立一个针对某服务器的cookie文件并由浏览器管理，用于记录用户信息，服务器的数据库保存不同cookie文件的识别码，在HTTP请求、响应报文中使用cookie首部行。 图2-4：cookie文件与识别码的关联过程 Cookie可以用于身份认证(存储用户名密码)，虚拟购物车(存储用户已选商品)，推荐广告(存储用户浏览习惯)，存储用户会话状态。缺点是Web站点可以收集用户信息，不安全。 2.2.5 Web缓存Web缓存器(Web cache)，也叫代理服务器(Proxy server)，位于客户机和服务器之间，保存客户机最近访问过的对象的副本，代表服务器响应客户机的HTTP请求。 用户配置浏览器将HTTP请求指向Web缓存器，若对象在缓存中，缓存器返回对象，若不在，缓存器向目标服务器发出请求，接收对象后转发给客户机，并保存。缓存器兼任服务器和客户机角色。 客户机与Web缓存器之间是高速链路，Web缓存器和服务器之间是低速链路，所以Web缓存可以减少Web响应的时间，减少因特网的使用流量，降低费用。 2.2.6 条件GET方法Web缓存器中存储的对象可能过时，所以使用条件GET方法检查并确保自己的对象拷贝为最新。Web缓存器第一次请求对象，目标服务器返回响应中包括对象的最后修改时间Last-modified:date1，此后Web缓存器定期向相应服务器发送条件GET报文，检查该对象是否已被修改，方法为GET，且包含首部行If-modified-since:date1，若对象未被修改，则目标服务器在状态行中响应：304 Not Modified，否则，在报文实体中返回修改后的对象。 2.3 文件传输协议：FTP文件传输协议是应用层协议，基于运输层TCP，作用是本地主机向远程主机上传或下载文件，采用C/S结构，用户通过一个FTP用户代理与FTP交互。 图2-5：文件传输协议 文件传输过程首先在FTP客户机进程与FTP服务器进程之间建立TCP连接，再输入用户名和口令进行身份验证，验证成功后进行文件传输。 FTP与HTTP都能基于TCP传输文件，但FTP使用了两个并行的TCP连接：控制连接和数据连接。 控制连接在两机控制进程间传输控制信息，如用户名、口令、操作命令与响应等，由客户发起，整个绘画过程中一直保持连接。服务器控制进程使用TCP 21号端口，客户机进程发送FTP命令，服务器返回响应。 图2-6：FTP命令与响应 数据连接在两机数据进程间传输文件，服务器在控制连接上收到文件传输的命令，并收到PORT命令得知客户数据进程端口号。服务器数据进程在TCP20端口主动发起建立数据连接，在该连接上传输文件，完成后关闭连接。每个文件的传送都要建立和关闭一次数据连接。 控制连接是持续的，整个FTP会话期间一直保持；数据连接是非持续的，会话中每次文件传输都要打开和关闭数据连接。 FTP协议是有状态的，服务器在会话期间存储用户状态，但限制了FTP同时维持的会话数量；HTTP协议是无状态的，服务器不存储用户的会话状态，开销更小。 2.4 电子邮件应用2.4.1 概述电子邮件系统的主要部分为用户代理、邮件服务器、邮件传输协议。 用户代理(user agent)：允许用户发送、接收、撰写、阅读、回复、保存邮件。发邮件时，用户代理向发送方邮件服务器发送邮件，并存放在输出报文队列中；收邮件时，用户代理从接收方邮件服务器的对应邮箱中获取邮件。 邮件服务器(mail server)：邮件服务器由输出报文队列和用户邮箱组成。邮件传输过程分为三阶段，从发送方用户代理到发送方邮件服务器的输出报文队列，使用SMTP或HTTP；发送方邮件服务器到接收方邮件服务器，保存到接收用户邮箱中，使用SMTP；接收方用户代理访问接收方邮件服务器，从相应邮箱下载邮件，使用POP3或IMAP或HTTP。 简单邮件传送协议SMTP(Simple Mail Transfer Protocol)：作用为从发送用户代理向发送方邮件服务器发送邮件；从发送方邮件服务器向接收方邮件服务器发送邮件，是应用层协议，基于TCP，服务器进程端口为25。 图2-7：在邮件服务器间的SMTP交互 2.4.2 SMTP与HTTP对比共同点：都传送文件；都使用持续连接，即一个TCP连接上可传送多个对象或电子邮件；单独都只能传送7位ASCII码格式的报文。 区别一：HTTP是拉协议，TCP连接由想获取文件的设备发起；SMTP是推协议，TCP连接是由要发送文件的设备发起。 区别二：对含有多个对象的文档，HTTP把每个对象分别封装在对应的HTTP响应报文中，SMTP则把所有对象放在一个报文中发送。 2.4.3 邮件报文格式 图2-8：邮件报文格式 2.4.4 邮件访问协议邮件访问协议的作用是用户代理从邮件服务器上读取邮件，分三种：POP3、IMAP、HTTP。 POP3(Post Office Protocol 3)：第三版的邮局协议，简单但功能有限。首先由客户机进程发起并建立TCP连接，服务器进程使用端口110侦听。之后开始读取邮件，分三个阶段：特许：用户代理发送用户名和口令，身份认证；事务处理：用户代理取回邮件报文，可以下载并保留、下载并删除；更新：邮件服务器删除带有标记的报文，并结束会话。 图2-9：POP3示例 IMAP(Internet Mail Access Protocol)：因特网邮件访问协议，功能更强，也是基于TCP，是一个联机协议，用户代理可以操作服务器的邮箱，如建立文件夹、移动邮件等，而POP3不行。可在用户代理上浏览邮件的摘要信息，再决定是否下载整个邮件，较复杂。 当用户代理为浏览器时，使用HTTP协议，邮件服务器之间传送仍使用SMTP。 2.5 目录服务DNS因特网中标识主机的方式有主机名，即有结构的字母数字如Einsturing.top，或IP地址，即有结构的4个或16个字节二进制，如IPv4地址(点分十进制)。存在两种地址转换的问题。 DNS(Domain Name System)：域名系统/目录服务，实现主机名与IP地址的相互转换。由分布式数据库和DNS协议组成。分布式数据库由分层的DNS服务器实现，记录了主机名与IP地址的对应信息；DNS协议用于客户机查询分布式数据库，获取对应的主机名或IP地址。是应用层协议，基于UDP，采用C/S方式工作，服务器进程使用端口UDP 53。 DNS服务器是如运行BIND软件的UNIX计算机，使用环境在于为其他应用层协议(如HTTP、SMTP、FTP)，提供主机名代IP地址的解析。 例如用户浏览器访问网页，会有以下过程：用户机上启用DNS客户机进程；浏览器将URL中主机名，传给DNS客户机进程；DNS客户机向默认DNS服务器发送包含主机名的DNS请求；DNS服务器查数据库后(可能要进行多级服务器查询)，返回含有对应IP地址的应答；浏览器使用该IP地址向HTTP服务器发起TCP连接，然后传送HTTP请求。 DNS提供主机名与IP地址的相互转换服务，主机别名到规范名的映射服务。 负载分配：多个提供相同服务的服务器使用同一个名字。 2.6 P2P应用端系统(对等方)之间直接通信，很少或者不使用服务器。典型应用有P2P文件分发如BT下载，P2P数据库。 BT(BitTorrent)是一个P2P文件分发协议，实现单个源向大量对等方快速分发文件。Torrent意为洪流，指参与文件分发的所有对等方。 P2P文件分发的工作特点为：洪流中，对等方彼此下载等长度的文件块；一个对等方可在任何时候加入洪流；下载文件块的同时，也为洪流中其他对等方上载文件块；对等方获得整个文件后可以离开，也可以留下，继续提供上载。 追踪器(tracker)：每个洪流有一个追踪器，用于跟踪此洪流的对等方，一个对等方加入洪流时，在追踪器中注册，并周期性地通知洪流，是否仍在洪流中。 BT工作原理：一个对等方A加入洪流时，追踪器从中随机选择一些对等方，将其IP地址列表发给A；A分别与列表中对等方建立TCP连接，从多个对等方获取文件块，同时，也通过追踪器为洪流中其他对等方提供已有文件块的下载；下载完成后，组装为一个完整的文件。 2.7 套接字编程网络应用程序通常包括客户机程序和服务器程序，通过套接字(socket)读写数据实现网络通信，开发前应先选择运输层协议，双方进程通过套接字向网络发收报文，程序开发者可以控制应用层短，不能控制运输层端(只能选择使用TCP或UDP，设置少数参数)。 2.7.1 TCP套接字编程先建立TCP连接，再传输数据。客户机进程是连接的发起方，服务器应先准备好，设备已经运行并且已经打开一个套接字(欢迎套接字)**，准备接受任何客户机发起的连接请求。 1）建立TCP连接：客户机创建一个本地套接字，并给出服务器进程地址(IP地址+端口号)；当服务器侦听到连接请求时，创建一个新套接字(连接套接字)，并经过“三次握手”与对方建立TCP连接。 2）传送用户数据。 流：流入或流出某进程的一串字符序列。 输入流：针对进程而言，来自某个输入源的数据，如来自键盘或来自套接字(网络)。 输出流：针对进程而言，去往某个输出源的数据，如去往显示器或去往套接字(网络)。 以下示例程序采用TCP通信，客户机从键盘读一行字符发给服务器，服务器将字符转换成大写发给客户机。 1234567891011121314151617181920212223242526272829#TCPClient.pyfrom socket import *serverName = '127.0.0.1'serverPort = 12000#套接字的创建 第一个参数指示IPv4，第二个参数表明是TCPclientSocket = socket(AF_INET,SOCK_STREAM)#执行三次握手并在客户和服务器之间创建一条TCP连接clientSocket.connect((serverName,serverPort))sentence = input('Input lowercase sentence:')clientSocket.send(sentence.encode())modifiedSentence = clientSocket.recv(1024)print('From Server: ',modifiedSentence.decode())#关闭套接字clientSocket.close()#TCPServer.pyfrom socket import *serverPort = 12000serverSocket = socket(AF_INET,SOCK_STREAM)serverSocket.bind(('',serverPort))#让服务器聆听来自客户的TCP连接请求，参数定义了请求连接的最大数(至少为1)serverSocket.listen(1)print('The server is ready to receive')while True: connectionSocket,addr = serverSocket.accept() sentence = connectionSocket.recv(1024).decode() capitalizedSentence = sentence.upper() connectionSocket.send(capitalizedSentence.encode()) connectionSocket.close() 2.7.2 UDP套接字编程UDP是一种无连接的服务，没有连接所需的握手阶段，数据传递以数据报为单位进行，数据报中含目的进程的地址(IP地址和端口号)，提供不可靠的传输服务。 通信进程之间没有初始握手，不需要欢迎套接字；没有流与套接字相关联；发送主机将信息封装生成数据报再发送；接收进程解封收到的数据报，获得信息。 以下示例程序同上节，但采用UDP通信。 1234567891011121314151617181920212223#UDPClient.pyfrom socket import *serverName = '127.0.0.1'serverPort = 12000#套接字的创建 第一个参数指示IPv4，第二个参数表明是UDPclientSocket = socket(AF_INET,SOCK_DGRAM)sentence = input('Input lowercase sentence:')clientSocket.sendto(sentence.encode(),(serverName,serverPort))modifiedSentence,serverAddress = clientSocket.recvfrom(2048)print('From Server: ',modifiedSentence.decode())#关闭套接字clientSocket.close()#UDPServer.pyfrom socket import *serverPort = 12000serverSocket = socket(AF_INET,SOCK_DGRAM)serverSocket.bind(('',serverPort))print('The server is ready to receive')while True: sentence,clientAddress = serverSocket.recvfrom(2048) modifiedSentence = sentence.decode().upper() serverSocket.sendto(modifiedSentence.encode(),clientAddress)]]></content>
      <categories>
        <category>Basics</category>
        <category>Computer Network</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第1章 计算机网络和因特网]]></title>
    <url>%2F2019%2F06%2F03%2FCN1%2F</url>
    <content type="text"><![CDATA[计算机网络从20世纪60年代发展至今，是计算机技术与通信技术相结合的产物，其定义如下 定义 计算机网络是用通信设备和通信链路连接起来，使用网络协议进行数据通信，实现资源共享的计算机的集合。 计算机网络由硬件和软件组成，硬件为 通信子网：通信设备和通信介质，用来传输数据； 资源子网：计算机及其硬件，用来存储和处理数据。 软件为 一系列网络协议：保证数据通信正确进行。 计算机网络类型众多，如局域网、广域网；有线网、无线网。最大的计算机网络为因特网。 1.1 什么是因特网因特网(Internet)：一个世界范围的计算机网络，互联遍及全世界的计算设备，是全球性的网络的网络。其具体由硬件(计算机、通信设备、通信链路)和软件(采用五层结构的一系列协议)构成，为分布式应用程序提供通信服务。 计算机(Computer)：也称为主机或端系统，功能为运行分布式应用程序，进行数据存储与处理。其类型有传统设备(PC、工作站、服务器等)和非传统设备(智能手机、游戏机等)。 通信链路(communication link)：连接不同设备的物理线路。类型有同轴电缆、双绞线、光纤、无线链路等。通信链路的数据指每秒传输多少位数据，单位bps；不同链路传输速率不同。 图1-1：通信链路 通信设备：因特网中的通信设备是分组交换机(packet switch)，分路由器(Router)和链路层交换机(Switch)，功能为接收、存储、转发分组。从一条通信链路接收分组、存储排队处理后，从另一条链路转发分组。 分组交换技术：发送主机将要发送的数据分成若干较小的块，添加控制信息形成分组(packet)，通过若干分组交换机的存储转发到达目的主机，再组装恢复原数据。一个分组从发送主机传输到接收主机，所经过的一系列通信链路和分组交换机称为路径。即使源和目的主机相同，每个分组所选路径可能不相同。且路径不专用，效率更高。 因特网服务提供商(Internet Service Provider,ISP)：由多个分组交换机和通信链路组成的网络，并由某机构管理运营，主机需要通过某个ISP接入因特网。ISP为分层结构，低层ISP通过高层ISP互联，对用户和内容提供者提供不同类型的网络接入。每个ISP独立管理，但都运行TCP/IP协议族。 协议(protocol)：保证网络通信正确进行的规则与约定，由硬件或软件程序实现，每个端系统和通信设备都要运行。因特网使用TCP(Transmission Control Protocol 传输控制协议)/IP(Internet Protocol 网际协议)协议族，含很多协议。每个协议有对应因特网标准，由IETF(Internet Engineering Task Force 因特网工程任务组)以RFC(Request For Comments 请求评论)文档形式发布。 图1-2：人类和网络对比(协议与规则) 网络协议：由设备的硬件或软件执行的写成程序。因特网活动都要遵守协议。例如邮件传输、远程登录、网页传输等。协议定义了报文的格式、含义和传输频序，即语法、语义和语序。不同协议完成不同的通信任务，如HTTP传输网页、SMTP传输电子邮件。 因特网为分布式应用程序提供两种通信服务，面向连接的可靠服务和无连接的不可靠的服务。 面向连接服务：两个端系统先要通过“握手过程”建立连接，然后才发送数据。握手过程指互相发送“控制”信息，在两个端系统之间创建连接，双方做好接收信息的准备。面向连接服务有三大特性：可靠的数据传输、流量控制、拥塞控制。 1）可靠的数据传输：端系统可以无差错、按序传递分组。对报文进行编号，当接收端收到分组时返回一个“确认”，如果发送端一段时间内未收到“确认”，重传该分组。 2）流量控制：当接收方缓存已满，降低发送速率，避免数据丢失。 3）拥塞控制：当网络出现拥塞时，降低特定发送端向网络发送分组的速率。 TCP提供面向连接服务，实现以上三种特性。使用TCP的分布式应用程序如Telnet(远程注册)、SMTP(电子邮件)、FTP(文件传输)、HTTP(Web)等。 无连接服务：两个主机通信前，不需要建立连接，可直接发送分组，效率更高。特点为不可靠，无流量控制和拥塞控制但工作效率高。 UDP(User Datagram Protocol 用户数据报协议)提供无连接服务，相关分布式应用程序如网络管理系统、网络参数自动分配等。 1.2 网络边缘网络分为两大部分，网络边缘(资源子网)如端系统和外围设备，分布式应用程序，网络核心(通信子网)如路由器、交换机，通信链路。 图1-3：网络边缘和网络核心 端系统即主机，在网络边缘运行分布式应用程序，分为客户机(client)和服务器(server)。客户机通常是个人计算机与设备，运行客户端软件，请求服务。服务器通常是功能更强的计算机，运行服务器端原件，提供服务。端系统间的工作模式有客户机/服务器(C/S)模式、对等(P2P)模式、混合模式。 (C/S)模式：存在客户机和服务器，被因特网广泛采用，如电子邮件传输、Web网页传输、文件传输等。 Peer to Peer(P2P)模式：很少或不适用专门的服务器。其特点为各端系统同时运行客户机和服务器程序，请求服务时是客户机，提供服务时是服务器，如BT(Bit Torrent比特洪流)下载。 1.3 网络核心网络核心由分组交换机和链路组成，用于数据传输。传输方式有电路交换和分组交换。 电路交换(circuit switching)：面向连接，提前预留通信路径上所需通信资源(缓存，链路带宽)，发送双方独占使用预留资源以恒定速率在同一物理连接上连续传送数据，如固定电话网。物理连接指固定路径。优点是保证恒定速率，通信质量好，缺点是创建电路、预留资源过程复杂，且静默期效率较低。发送方发送一个文件的时间为创建电路时间加文件传输时间。 多路复用(multiplexing)：在一条通信链路上分别为不同连接传输数据。电路交换网的多路复用有频分多路复用FDM(frequenct-division multiplexing)，链路的频谱划分成若干频段，每个频段专用于一个连接，和时分多路复用TDM(time-division multiplexing)，链路的传输时间划分为若干固定时长的帧，帧再划分为固定数量的时隙，每一个时隙专用于一个连接的一块数据的传输。 分组交换(packet switching)：可面向连接和无连接，不会预留资源，通信时按需共享使用资源，以分组的方式采用逻辑连接或无连接方式传送，可能要排队等待，速率不恒定，如因特网。逻辑连接指底层数据走不同路径，中上层通过采取措施，使得从应用程序看起来是同一路径过来的一样。分组交换的工作过程为，源端将报文划分为较小的分组(含控制信息)，每个分组独自通过一系列链路和分组交换机传送到达目的端，目的端组合并恢复原报文。共享使用链路，以最大速率传输。 分组交换的存储转发：分组交换机将输入的整个分组接收下来存储，计算处理后，再从某输出链路传输出去(转发)。 输出的排队时延：输出缓存指用于保存准备发往某个链路的分组，每个链路端口都有一个。排队时延指分组在输出缓存中等待发送的时间，是变化的，与网络拥塞有关。分组丢失指当缓存已满，后续再有分组进入，根据规则丢弃一些分组。 报文交换(message switching)：将要发送的整个信息作为一个报文(message)发送，如电报网络。其类似分组交换，也采用存储转发，但以整个报文为单位。 分组交换网分为面向连接的虚电路网络和无连接的数据报网络。 虚电路网络：分组交换机根据虚电路号ID转发分组，要先建立虚电路连接(非专用的物理电路)，每个虚电路有一个标识符ID，分组带有此ID，交换机据此决定下一跳，通过措施保证相同ID的分组沿同一虚电路按序到达。如X.25、帧中继FR、异步传递方式ATM网络。 数据报网络：分组交换机根据目的地址转发分组，不需建立连接，每个分组携带目的地址，交换机据此决定下一跳。 网络的分类： 1）根据交换方式 图1-4：网络交换方式 图1-5：四种交换方式 2）根据地理覆盖范围 局域网(Local Area Network,LAN)：覆盖范围较小，用户数少、配置容易、用户端速率较快。 城域网(Metropolitan Area Network,MAN)：同一城市，不同地理范围的网络，覆盖范围在广域网和局域网之间，使用光纤连接。主干传输速率比LAN高。 广域网(Wide Area Network,WAN)：也叫远程网，覆盖范围广，为不规则网状结构。主干线路速率高但用户端速率低。 3）根据拓扑结构 拓扑结构指网络的物理连接方式。 图1-6：网络的拓扑结构 总线：所有结点连接到一条公共传输线上，通过该总线传输信息(双向)。其结构简单、方便、易于扩充、成本都，但传输距离有限且实时性差，用于早期的以太网。 树形：由总线结构派生，易于扩展，但对“根”的依赖性大，如有线广播电视网。 星形：以中央结点为中心，连接若干外围结点，如集线器或交换机。结构简单、连网方便、成本低，但中心结点依赖性大，用于小型局域网。 环形：结点连接成一个闭合的环，信息单向传输。结构简单、路径选择方便，但可靠性差、管理复杂。用于早期局域网和城域网。 网状/分布式：每个结点和其他任意结点至少有两条线路相连。可靠性高，但网络控制和软件比较复杂。 4）根据使用范围 公用网(Public Network)：面向大众，付费使用，如Internet。 专用网(Private network)：单位内部使用，如军用、金融网络。 1.4 网络接入和物理媒体网络接入(network access)：将端系统连接到边缘路由器。接入方式有住宅接入(家庭用户)，公司接入(学校、单位)，无线接入(移动设备)。 边缘路由器(edge router)：端系统到网络的第一台路由器。 住宅接入即将家庭的端系统(如PC)与边缘路由器相连接，可通过拨号调制解调器或使用新型宽带接入技术。 1）通过拨号调制解调器：端系统通过模拟电话线和调制解调器与因特网服务提供商(ISP)的路由器相连。但上网速度慢，通信不稳定，不能同时上网和拨打固定电话。 2）新型宽带接入技术：常用的有数字用户线DSL(Digital Subscriber Line)，混合光纤同轴电缆HFC(Hybrid Fiber Coaxial cable)，光纤入户FTTH(Fiber To The Home)，无线方式。 公司接入先将多个端系统连接成局域网，再与边缘路由器连接，边缘路由器负责与外网连接。 无线接入用于无线移动设备的接入，有无线局域网(wireless LAN)，广域无线接入网(wide-area wireless access network)。前者也称Wi-Fi，后者即4G等技术。 物理媒体(physical medium)：将网络中不同设备互连起来的物理链路，通过传播电磁波来传输比特流，也称传输介质、通信链路。分为电磁波沿固体媒体传播的导引型媒体如双绞线、同轴电缆、光缆等，和电磁波在空气或外层空间中传播的非导引型媒体。 双绞线(twisted pair,TP)：两根绝缘的铜线螺旋形式扭合在一起，减少对邻近双绞线的电气干扰。可以传输模拟信号或数字信号，传输速率与铜线的直径和传输距离有关。 同轴电缆(Coaxial Cable)：套在一起的两个同心铜导体，内导体传递数据，外导体用作地线及屏蔽干扰，分基带同轴电缆和宽带同轴电缆。抗干扰能力强，数据率高。 光纤(Fiber)：由纤芯和包层构成，纤芯用来传导光波。很细(几微米)、传送光脉冲(每个脉冲表示一个比特)、频带宽(最高10GHz以上)、抗干扰能力强。 陆地无线电信道：利用无线电波在空间传播实现通信，不需物理线路，能穿透墙壁连接移动用户，性能与环境和距离有关。分局域(Wi-Fi)和广域(4G)。 卫星无线电信道：通过通信卫星连接两个或多个位于地球的微博发射方/接收方。 1.5 ISP和因特网主干端系统通过接入ISP与因特网相连，因特网由数以亿计的用户和几十万个网络构成，其结构采用分层ISP的方式，属于”网络的网络“。 第一层ISP(tier-1 ISP)位于最顶层，数量少，是因特网主干网络，覆盖国际。与一般网络类似，但速率高，ISP之间互相对等(peer)，不存在从属关系。 第二层ISP常为区域的覆盖，可与多个第一层ISP相连，与第一层为客户与提供商关系。第二层相互之间是对等关系。 第三层ISP和接入ISP最靠近端系统，通过第二层ISP与因特网相连，是第二层的客户。 图1-7：分组在因特网传输 1.6 分组交换网的时延、丢包与吞吐量一段链路有四种时延：处理时延、排队时延、传输时延、传播时延。 处理时延(processing delay)：检查比特差错，查路由表决定输出链路时的时延，通常是微秒级。 排队时延(queuing delay)：分组在输出缓存上等待传输的排队时间，与正在排队的分组数量、到达分组的数量、到达该队列流量的强度和性质有关。可以是毫秒到微妙级。 传输时延(transmission delay)：路由器将分组的所有比特推向链路所需时间。传输时延$=L/R$，$L$为分组长度(b)，$R$为链路的传输速率(bps)，与传播速率区分开来。通常在毫秒到微秒级。 传播时延(propagation delay)：一个比特从链路的起点到下一结点传播所需要的时间。传播时延$=d/s$，$d$为两结点之间的距离，$s$为信号在链路上单位时间内传送的距离。 一个结点与一段链路的总时延$d{nodal}=d{proc}+d{queue}+d{trans}+d_{prop}$。 其中排队时延最为复杂，因为传输时每个分组的排队时延不同，因此使用统计量计算排队时延。排队时延的大小取决于流量到达队列的速率、到达流量的性质(周期性或突发形式)和链路传输的速率。 流量强度(traffic intensity)：比特到达队列的速率与从队列输出的速率之比。 令$a=$平均分组到达速率(bps)，则流量强度$=La/R$。 图1-9：平均排队时延与流量强度关系 通常，一条链路的输出缓存队列容量有限，当到达的分组发现队列已满，没有空间存储时，将被丢弃，此现象为分组丢失，即丢包。丢包可能由源主机进行重传。 分组从源到目的地的时延称为端到端时延。设源主机和目的主机之间有$N-1$个路由器，假设网络无拥塞(忽略排队时延)，路由器和源主机的处理时延是$d{proc}$，路由器和源主机的输出速率是$R b/s$，则路由器和源主机的传输时延$d{trans}=L/R$，每条链路的传播时延是$d{prop}$，每个结点与后续链路时延为$d{proc}+d{trans}+d{prop}$，端到端时延$d{end-end}=N(d{proc}+d{trans}+d{prop})$。 吞吐量(throughput)：端到端吞吐量指通信中接收方接收数据的平均数据，分瞬时吞吐量和平均吞吐量。端到端吞吐量是瓶颈链路(bottleneck link)的传输速率。 图1-10：端到端吞吐量 1.7 协议层次与服务模型因特网采用分层的体系结构，每层实现相对独立的功能，每层利用下一层次所提供的服务。分层的优点在于能简化复杂系统的实现，且易于维护和更新。只要保持向上层提供的服务和向下层使用的服务不变，某层内部的变化不会影响其他层次。 协议分层：每层都有一系列协议，协议通过软件、硬件实现，运行在不同设备中，称为协议栈(protocol stack)。OSI协议栈有七层；TCP/IP协议栈有五层。 OSI/RM(Open System Interconnection/Reference Model 开放系统互连参考模型)如下 序号 名称 主要解决问题 主要功能 负责范围 单位 1 物理层 物理上可达 定义机械、电气、功能、规程特性 物理线路 比特 2 数据链路层 相邻结点间(链路上)无差错 帧的检错与纠错(CRC码)；多路访问；链路层寻址 链路 帧 3 网络层 主机-主机的路由、拥塞控制等网络选路问题 实现主机到主机的路由；拥塞控制 主机-主机 分组 4 运输层 进程端口-进程端口的端到端传输问题 实现进程到进程的传输中的复用；流量控制；可靠性 端口-端口 报文段 5 会话层 会话时序问题(什么时候连接、传输和关闭连接等) 规定通信时序；数据交换的同步，建立检查点等 应用程序 报文 6 表示层 压缩、加密等表示问题 规定数据的表示、格式转换等 应用程序 报文 7 应用层 为用户和分布式应用程序提供访问网络的接口 为用户和分布式应用程序提供访问网络的接口 应用程序 报文 OSI协议栈详细而复杂，未被工业界所使用。而因特网协议栈(TCP/IP协议栈)只实现必要功能，已成为事实上的工业标准，其内容如下。 应用层：为主机各种分布式应用程序提供所需网络服务，处理单元为报文，用软件实现。FTP、SMTP、HTTP、SNMP。 运输层：在不同主机进程之间传输报文段，用软件实现。TCP和UDP。 网络层：在主机之间传输IP数据报(IP分组)，硬件、软件混合。IP、IGMP、选路协议。 链路层：在相邻结点之间无差错的传输帧，硬件实现。PPP、以太网、无线网协议。 物理层：在结点之间传输比特流，硬件实现。传输媒体、拓扑结构。 数据传递中发送方将数据自顶向下逐层封装，接收方将收到的数据自底向上逐层解封。 图1-11：封装及解封全过程]]></content>
      <categories>
        <category>Basics</category>
        <category>Computer Network</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1080 国王游戏]]></title>
    <url>%2F2019%2F04%2F14%2F%E6%B4%9B%E8%B0%B7P1080%2F</url>
    <content type="text"><![CDATA[Description恰逢H国国庆，国王邀请n位大臣来玩一个有奖游戏。首先，他让每个大臣在左、右手上面分别写下一个整数，国王自己也在左、右手上各写一个整数。然后，让这n位大臣排成一排，国王站在队伍的最前面。排好队后，所有的大臣都会获得国王奖赏的若干金币，每位大臣获得的金币数分别是：排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数，然后向下取整得到的结果。 国王不希望某一个大臣获得特别多的奖赏，所以他想请你帮他重新安排一下队伍的顺序，使得获得奖赏最多的大臣，所获奖赏尽可能的少。注意，国王的位置始终在队伍的最前面。 Input第一行包含一个整数n，表示大臣的人数。 第二行包含两个整数a和b，之间用一个空格隔开，分别表示国王左手和右手上的整数。 接下来n行，每行包含两个整数a和b，之间用一个空格隔开，分别表示每个大臣左手和右手上的整数。 Output一个整数，表示重新排列后的队伍中获奖赏最多的大臣所获得的金币数。 Sample Input123453 1 1 2 3 7 4 4 6 Sample Output12 Analysis一番玄学数学证明后可发现规律，采用贪心可解，但是数据过大需要高精算法，可是我根本不会高精，于是使用python偷懒2333。 以下为证明。 假设队列如下： \begin{array} &&left&right\\ king&a0&b0\\ p1&a1&b1\\ p2&a2&b2 \end{array}可得$ans1=max(\frac{a0}{b1},\frac{a0*a1}{b2})​$ 再假设队列如下： \begin{array} &&left&right\\ king&a0&b0\\ p1&a2&b2\\ p2&a1&b1 \end{array}可得$ans2=max(\frac{a0}{b2},\frac{a0*a2}{b1})$ 而显然，有： \frac{a0*a1}{b2}>\frac{a0}{b2}\rightarrow ans1=\frac{a0*a1}{b2}\\ \frac{a0*a2}{b1}>\frac{a0}{b1}\rightarrow ans2=\frac{a0*a2}{b1}如果令$ans2&gt;ans1$ 则有 \frac{a0*a2}{b1}>\frac{a0*a1}{b2}约分得$a1b1&lt;a2b2$ 因此，为了得到最小的ans，需要将$ai*bi$按升序排列。 Code123456789101112131415161718192021222324s=input().split()n=int(s[0])s=input().split()a,b=int(s[0]),int(s[1])dc=[]for i in range(n): dc.append(&#123;'a':0,'b':0&#125;) s=input().split() dc[i]['a']=int(s[0]) dc[i]['b']=int(s[1]) passdc.sort(key=lambda d:(d['a']*d['b']))pre=[a]ans=0for i in range(n): ans=max(ans,pre[i]//dc[i]['b']) pre.append(pre[i]*dc[i]['a']) passprint(ans)]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Mathematical</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
        <tag>高精</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[100-Days-Of-ML-Code Day11 K近邻法(K-NN)]]></title>
    <url>%2F2019%2F04%2F11%2F100%E5%A4%A9ML-11%2F</url>
    <content type="text"><![CDATA[k近邻法(k-NN)|第11天Steps Datasets Code第1步：数据预处理12345678910111213141516#导入相关库import numpy as npimport matplotlib.pyplot as pltimport pandas as pd#导入数据集dataset = pd.read_csv('Social_Network_Ads.csv')X = dataset.iloc[:,[2,3]].valuesY = dataset.iloc[:,4].values#将数据集划分成训练集和测试集from sklearn.model_selection import train_test_splitX_train,X_test,Y_train,Y_test = train_test_split(X,Y,test_size = 0.25,random_state = 0)#特征缩放from sklearn.preprocessing import StandardScalersc = StandardScaler()X_train = sc.fit_transform(X_train)X_test = sc.transform(X_test) 第2步：使用K-NN对训练集数据进行训练12345678910111213#使用K-NN对训练集数据进行训练from sklearn.neighbors import KNeighborsClassifierclassifier = KNeighborsClassifier(n_neighbors = 5,metric = 'minkowski',p = 2)#KNeighborsClassifier(n_neighbors=5, weights=’uniform’, algorithm=’auto’, leaf_size=30, p=2, metric=’minkowski’, metric_params=None, n_jobs=None, **kwargs)#n_neighbors:就是选取最近的点的个数K#weights:K个近邻样本的权重#algorithm:使用的算法#leaf_size:停止建子树的叶子节点阈值#p:距离度量附属参数，p=1为曼哈顿距离， p=2为欧式距离，默认为2#metric:距离度量，默认为闵可夫斯基距离，与p共同决定#metric_params:其他附属参数。主要是用于带权重闵可夫斯基距离的权重，以及其他一些比较复杂的距离度量的参数#n_jobs:并行处理任务数,主要用于多核CPU时的并行处理，加快建立KNN树和预测搜索的速度classifier.fit(X_train,Y_train) 第3步：预测12#对测试集进行预测Y_pred = classifier.predict(X_test) 第四步：评估预测123#生成混淆矩阵from sklearn.metrics import confusion_matrixcm = confusion_matrix(Y_test,Y_pred) 训练集可视化12345678910111213from matplotlib.colors import ListedColormapX_set,Y_set = X_train,Y_trainX1,X2 = np.meshgrid(np.arange(start = X_set[:,0].min() - 1,stop = X_set[:,0].max() + 1,step = 0.01),np.arange(start = X_set[:,1].min() - 1,stop = X_set[:,1].max() + 1,step = 0.01))plt.contourf(X1,X2,classifier.predict(np.array([X1.ravel(),X2.ravel()]).T).reshape(X1.shape),alpha = 0.75,cmap = ListedColormap(('red','green')))plt.xlim(X1.min(),X1.max())plt.ylim(X2.min(),X2.max())for i,j in enumerate(np.unique(Y_set)): plt.scatter(X_set[Y_set == j,0],X_set[Y_set == j,1],c = ListedColormap(('black','white'))(i),label = j)plt.title('K Nearest Neighbours(Training set)')plt.xlabel('Age')plt.ylabel('Estimated Salary')plt.legend()plt.show() 测试集可视化123456789101112X_set,Y_set=X_test,Y_predX1,X2 = np.meshgrid(np.arange(start = X_set[:,0].min() - 1,stop = X_set[:,0].max() + 1,step = 0.01),np.arange(start = X_set[:,1].min() - 1,stop = X_set[:,1].max() + 1,step = 0.01))plt.contourf(X1,X2,classifier.predict(np.array([X1.ravel(),X2.ravel()]).T).reshape(X1.shape),alpha = 0.75,cmap = ListedColormap(('red','green')))plt.xlim(X1.min(),X1.max())plt.ylim(X2.min(),X2.max())for i,j in enumerate(np.unique(Y_set)): plt.scatter(X_set[Y_set == j,0],X_set[Y_set == j,1],c = ListedColormap(('black','white'))(i),label = j)plt.title('K Nearest Neighbours(Test set)')plt.xlabel('Age')plt.ylabel('Estimated Salary')plt.legend()plt.show()]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Note of Machine Learning 5]]></title>
    <url>%2F2019%2F03%2F31%2FML5%2F</url>
    <content type="text"><![CDATA[第5章 神经网络5.1 神经元模型神经网络(neural networks)是由具有适应性的简单单元组成的广泛并行互连的网络，它的组织能够模拟生物神经系统对真实世界物体所作出的交互反应。 神经网络中最基本的成分是神经元(neuron)模型。如果某神经元的电位超过了一个”阈值”(threshold)，那么它就会被激活。上述情形可以抽象为图5.1所示的简单模型，即”M-P神经元模型”。在这个模型中，神经元接收到来自n个其他神经元传递过来的输入信号，这些输入信号通过带权重的连接(connection)进行传递，神经元接收到的总输入值将与神经元的阈值进行比较，然后通过”激活函数”(activation function)处理以产生神经元的输出。 理想的激活函数是图5.2(a)所示的阶跃函数，将输入值映射为输出值”0”(神经元抑制)或”1”(神经元兴奋)。然而碍于其性质，实际常用如图5.2(b)的Sigmoid函数作为激活函数也称为”挤压函数”(squashing function)。 事实上，可以将一个神经网络视为包含了许多参数的数学模型，这个模型是若干个函数，例如$y_i=f(\sum_iw_ix_i-\theta_j)$相互(嵌套)代入而得。 5.2 感知机与多层网络感知机(Perceptron)由两层神经元组成，如图5.3所示。输入层接受外界输入信号后传递给输出层，输出层是M-P神经元，亦称”阈值逻辑单元”(threshold logic unit)。感知机能容易地实现逻辑与、或、非运算。 一般地，给定训练数据集，权重$wi(i=1,2,\dots,n)$以及阈值$\theta$可通过学习得到。阈值$\theta$可看作一个固定输入为-1.0的”哑结点”(dummy node)所对应的权重$w{n+1}$，这样权重和阈值的学习就可统一为权重的学习。感知机学习规则非常简单，对训练样例$(x,y)$，若当前感知机的输出为$\hat y$，则感知机的权重将这样调整: w_i\leftarrow w_i+\Delta w_i, (5.1)\\ \Delta w_i=\eta(y-\hat y)x_i, (5.2)其中$\eta\in(0,1)$称为学习率(learning rate)。从式(5.1)可看出，若感知机对训练样例$(x,y)$预测正确，则感知机不发生变化，否则将根据错误的程度进行权重调整。 感知机只拥有一层功能神经元(functional neuron)，学习能力非常有限。事实上，上述与、或、非问题都是线性可分(linearly separable)的问题，可以证明若两类模式是线性可分的，即存在一个线性超平面将其分开，如图5.4(a)-(c)，则感知机的学习过程一定会收敛(converge)而求得适当的权向量$w=(w1;w_2;\dots;w{n+1})$；否则感知机学习过程会发生振荡(fluctuation)，w难以稳定。例如感知机不能解决图5.4(d)的亦或问题。 要解决非线性可分问题，考虑使用多层功能神经元，如图5.5(a)，输入层与输出层之间的一层神经元被称为隐层或隐含层(hidden layer)，隐含层和输出层都是拥有激活函数的功能神经元。 更一般的神经网络是如图5.6所示的层级结构，通常称为”多层前馈神经网络”(multi-layer feedforward neural networks)，输入层接受外界输入，隐层与输出层对信号加工，结果由输出层输出。神经网络的学习过程，就是根据训练数据来调整神经元之间的”连接权”(connection weight)以及每个功能神经元的阈值。 5.3 误差逆传播算法简单感知机学习规则不够训练多层网络。误差逆传播(error BackPropagation，简称BP)是迄今最成功的神经网络算法。 给定训练集$D={(x1,y_1),(x_2,y_2),\dots,(x_m,y_m)},x_i\in\mathbb{R}^d,y_i\in\mathbb{R}^l$，即输入示例由d个属性描述，输出l维实值向量。图5.7为拥有d个输入神经元、l个输出神经元、q个隐层神经元的多层前馈网络结构，$\theta_j$为输出层第j个神经元的阈值，$\gamma_h$为隐层第h个神经元的阈值。$v{ih}$为输入层第i个神经元与隐层第h个神经元的连接权，$w{hj}$为隐层第h个神经元与输出层第j个神经元的连接权。记隐层第h个神经元接收到的输入为$\alpha_h=\sum{i=1}^dv{ih}x_i$，输出层第j个神经元接收到的输入为$\beta_j=\sum{h=1}^qw_{hj}b_h$，其中$b_h$为隐层第h个神经元的输出。假设隐层和输出层神经元都使用Sigmoid函数。 对训练例$(x_k,y_k)$，假定神经网络的输出为$\hat{y}_k=(\hat{y}_1^k,\hat{y}_2^k,\dots,\hat{y}_l^k)$，即 \hat{y}_j^k=f(\beta_j-\theta_j), (5.3)则网络在$(x_k,y_k)$上的均方误差为 E_k=\frac{1}{2}\sum_{j=1}^l(\hat{y}_j^k-y_j^k). (5.4)BP是一个迭代学习算法，在迭代的每一轮中采用广义的感知机学习规则对参数进行更新估计，任意参数v的更新估计式为 v\leftarrow v+\Delta v. (5.5)以图5.7中隐层到输出层的连接权$w_{hj}$为例进行推导。BP基于梯度下降(gradient descent)策略。对式(5.4)的误差$E_k$，给定学习率$\eta$，有 \Delta w_{hj}=-\eta\frac{\partial E_k}{\partial w_{hj}}. (5.6)注意到$w_{hj}$先影响到第j个输出层神经元的输入值$\beta_j$，再影响到其输出值$\hat{y}_j^k$，然后影响到$E_k$，有 \frac{\partial E_k}{\partial w_{hj}}=\frac{\partial E_k}{\partial\hat{y}_j^k}\cdot\frac{\partial\hat{y}_j^k}{\partial\beta_j}\cdot\frac{\partial\beta_j}{\partial w_{hj}}. (5.7)根据$\beta_j$的定义，显然有 \frac{\partial\beta_j}{\partial w_{hj}}=b_h.图5.2中的Sigmoid函数有一个很好的性质： f'(x)=f(x)(1-f(x)), (5.9)于是根据式(5.4)和(5.3)，有 \begin{aligned} g_j&=-\frac{\partial E_k}{\partial \hat{y}_j^k}\cdot\frac{\partial\hat{y}_j^k}{\partial\beta_j}\\ &=-(\hat{y}_j^k-y_j^k)f'(\beta_j-\theta_j)\\ &=\hat{y}_j^k(1-\hat{y}_j^k)(y_j^k-\hat{y}_j^k). (5.10) \end{aligned}将式(5.10)和(5.8)代入式(5.7)，再代入式(5.6)，就得到了BP算法中关于$w_{hj}$的更新公式 \Delta w_{hj}=\eta g_jb_h. (5.11)类似可得 \Delta\theta_j=-\eta g_j, (5.12)\\ \Delta v_{ih}=\eta e_hx_i, (5.13)\\ \Delta \gamma_h=-\eta e_h, (5.14)式(5.13)和式(5.14)中 \begin{aligned} e_h&=-\frac{\partial E_k}{\partial b_h}\cdot\frac{\partial b_h}{\partial\alpha_h}\\ &=-\sum_{j=1}^l\frac{\partial E_k}{\partial\beta_j}\cdot\frac{\partial\beta_j}{\partial b_h}f'(\alpha_h-\gamma_h)\\ &=\sum_{j=1}^lw_{hj}g_jf'(\alpha_h-\gamma_h)\\ &=b_h(1-b_h)\sum_{j=1}^lw_{hj}g_j. (5.15) \end{aligned}学习率$\eta\in(0,1)$控制算法每一轮迭代中的更新步长，太大容易振荡，太小收敛速度过慢。可令式(5.11)与(5.12)使用$\eta_1$，式(5.13)与(5.14)使用$\eta_2$来进行精细调节，两者未必相等。 图5.8为BP算法的工作流程，图5.9给出了在2个属性、5个样本的西瓜数据上，随着训练轮数的增加，网络参数和分类边界的变化情况。需注意的是，BP算法的目标是要最小化训练集D上的累积误差 E=\frac{1}{m}\sum_{k=1}^mE_k, (5.16) 上述”标准BP算法”每次仅针对一个训练样例更新连接权和阈值，如果类似地推导出基于累积误差最小化的更新规则，就得到了累积误差逆传播(accumulated error backpropagation)算法。累积BP算法直接针对累积误差最小化，在读取整个训练集D后才对参数进行更新，参数更新的频率低得多。标准BP算法和累积BP算法的区别类似于随机梯度下降(stochastic gradient descent,SGD)与标准梯度下降之间的区别。 只需一个包含足够多神经元的隐层，多层前馈网络就能以任意精度逼近任意复杂度的连续函数。如何设置隐层神经元的个数通常靠”试错法”(trial-by-error)调整。 BP神经网络经常遭遇过拟合，有两种解决办法。第一种策略是”早停”(early stopping)：将数据分成训练集和验证集，训练集用来计算梯度、更新连接权和阈值，验证集用来估计误差，若训练集误差降低而验证集误差升高则停止训练，同时返回具有最小验证集误差的连接权和阈值。第二种策略是”正则化”(regularization)：在误差目标函数中增加一个用于描述网络复杂度的部分，仍令$E_k$表示第k个训练样例上的误差，$w_i$表示连接权和阈值，则误差目标函数(5.16)变为 E=\lambda\frac{1}{m}\sum_{k=1}^mE_k+(1-\lambda)\sum_iw_I^2, (5.17)其中$\lambda\in(0,1)$用于对经验误差与网络复杂度这两项进行折中，常通过交叉验证法来估计。 5.4 全局最小与局部极小神经网络的训练过程可看作在参数空间中寻找一组最优参数使E最小。有两种”最优”：”局部极小”(local minimum)和”全局最小”(global minimum)。局部极小不一定是全局最小，全局最小一定是局部极小。如果误差函数有多个局部极小，则不能保证找到的是全局最小。如图5.10。 有以下策略来跳出局部极小进一步接近全局最小： 以多组不同参数值初始化多个神经网络，取其中误差最小的解作为最终参数。 “模拟退火”(simulated annealing)，在每一步都以一定的概率接受比当前解更差的结果，从而有助于跳出局部极小。每步迭代过程中，接受次优解的概率要随时间推移而逐渐降低，从而保证算法稳定。 随机梯度下降。计算梯度时随机选择样本的子集，即使陷入局部极小，梯度也可能不为零。 此外，遗传算法(genetic algorithms)也常用来训练神经网络以更好地逼近全局最小。 5.5 其他常见神经网络神经网络模型、算法繁多，以下为几种常见网络。 5.5.1 RBF网络RBF(Radial Basis Function，径向基函数)网络是一种单隐层前馈神经网络，它使用径向基函数作为隐层神经元激活函数，输出层是对隐层神经元输出的线性组合。假定输入为d维向量x，输出为实值，则RBF网络可表示为 \varphi(x)=\sum_{i=1}^qw_i\rho(x,c_i), (5.18)q为隐层神经元个数，$c_i$和$w_i$分别是第i个隐层神经元所对应的中心和权重，$\rho(x,c_i)$是径向基函数，这是某种沿径向对称的标量函数，通常定义为样本x到数据中心$c_i$之间欧式距离的单调函数。常用的高斯径向基函数形如 \rho(x,c_i)=e^{-\beta||x-c_i||^2}. (5.19)具有足够多隐层神经元的RBF网络能以任意精度逼近任意连续函数。通常采用两步过程来训练RBF网络：第一步，确定神经元中心$c_i$，常用的方式包括随机采样、聚类等；第二步，利用BP算法等来确定参数$w_i$和$\beta_i​$。 5.5.2 ART网络竞争型学习(competitive learning)是神经网络一种常用无监督学习策略，网络的输出神经元相互竞争，每一时刻仅有一个竞争获胜的神经元被激活。这种机制亦称”胜者通吃”(winner-take-all)原则。 ART(Adaptive Resonance Theory，自适应谐振理论)网络是竞争性学习的重要代表。由比较层、识别层、识别阈值和重置模块构成。比较层负责接收输入样本，并将其传递给识别层神经元。识别层每个神经元对应一个模式类，神经元数目可在训练过程中动态增长以增加新的模式类。 在接收到比较层的输入信号后，识别层神经元相互竞争：计算输入向量与每个识别层神经元所对应的模式类的代表向量之间的距离，最小者胜。获胜神经元发送信号抑制其他识别层神经元激活。若输入向量与获胜神经元所对应的代表向量的相似度大于识别阈值，则当前输入样本被归为该代表向量所属类别，同时更新网络连接权，使该获胜神经元在以后有相似输入样本时更容易获胜；否则，重置模块将在识别层增设一个新的神经元，其代表向量设置为当前输入向量。当识别阈值高时，输入样本被分成比较多、比较精细的模式类，阈值低则反之。 ART缓解了竞争型学习中的”可塑性-稳定性窘境”(stability-plasticity dilemma)，可塑性指神经网络有学习新知识的能力，稳定性指神经网络在学习新知识时保持对旧知识的记忆。这使得ART网络具有一个很重要的优点：可进行增量学习(incremental learning)或在线学习(online learning)。增量学习指学得模型后，再接受样例时仅需根据新样例对模型进行更新，不必重新训练，先前学得的有效信息不会被冲掉；在线学习是每获得一个新样本就进行一次模型更新，是增量学习的特例。增量学习可视为”批模式”(batch-mode)的在线学习。 5.5.3 SOM网络SOM(Self-Organizing Map，自组织映射，Self-Organizing Feature Map，自组织特征映射，Kohonen网络)网络是一种竞争学习型的无监督神经网络，它能将高维输入数据映射到低维空间(通常为二维)，同时保持输入数据在高维空间的拓扑结构，即将高维空间中相似的样本点映射到网络输出层中的邻近神经元。 如图5.11，SOM中输出层神经元以矩阵方式排列在二维空间。其训练目标就是为每个输出层神经元找到合适的权向量，以达到保持拓扑结构的目的。 SOM训练过程：接收到一个训练样本后，每个输出层神经元计算该样本与自身携带的全向量之间的距离，距离最近的神经元成为竞争获胜者，称为最佳匹配单元(best matching unit)。然后最佳匹配单元及其近邻神经元的权向量将被调整，以使得这些权向量与当前输入样本的距离缩小。过程迭代到收敛。 5.5.4 级联相关网络一般的神经网络模型通常假定网络结构固定，而结构自适应网络，亦称”构造性”(constructive)神经网络，则将网络结构也当作学习的目标，在训练过程中找到最符合数据特点的网络结构。级联相关(Cascade-Correlation)网络是其重要代表(ART也是一种)。 级联相关网络有两个主要成分：”级联”和”相关”。级联是建立层次连接的层级结构。开始训练时，网络只有输入层和输出层，处于最小拓扑结构；随着训练进行，如图5.12，新的隐层神经元逐渐加入，从而创建起层级结构。当新的隐层神经元加入时，其输入端连接权值是冻结固定的。相关是指通过最大化新神经元的输出与网络误差之间的相关性(correlation)来训练相关的参数。 级联相关网络训练速度快，但数据较小时容易过拟合。 5.5.5 Elman网络与前馈神经网络不同，”递归神经网络”(recurrent neural networks)允许网络中出现环形结构，从而可让一些神经元的输出反馈回来作为输入信号。这样的结构与信息反馈过程，使得网络在t时刻的输出状态不仅与t时刻的输入有关，还与t-1时刻的网络状态有关，从而能处理与时间有关的动态变化。 Elman网络是最常用递归神经网络之一，如图5.13。隐层神经元的输出反馈回来作为下一时刻的输入，隐层神经元通常采用Sigmoid函数，训练通过推广的BP算法进行。 5.5.6 Boltzmann机神经网络中有一类模型是为网络状态定义一个”能量”(energy)，能量最小化时达到理想状态，网络的训练就是在最小化这个能量函数。Boltzmann机就是一种”基于能量的模型”(energy-based model)，常见结构如图5.14(a)，也是一种递归神经网络。其神经元分为显层和隐层。显层用于表示数据的输入和输出，隐层被理解为数据的内在表达。Boltzmann机中神经元都是布尔型的，只能取0、1两种状态，1表示激活，0表示抑制。令向量$s\in{0,1}^n$表示n个神经元的状态，$w_{ij}$表示神经元i与j之间的连接权，$\theta_j$表示神经元i的阈值，则状态向量s所对应的Boltzmann机能量定义为 E(s)=-\sum_{i=1}^{n-1}\sum_{j=i+1}^nw_{ij}s_is_j-\sum_{i=1}^n\theta_is_i. (5.20)若网络中的神经元以任意不依赖于输入值的顺序进行更新，则网络最终将达到Boltzmann分布，亦称”平衡态”(equilibrium)或”平衡分布”(stationary distribution)，此时状态向量s出现的概率将仅由其能量与所有可能状态向量的能量确定： P(s)=\frac{e^{-E(s)}}{\sum_te^{-E(t)}}. (5.21)Boltzmann机的训练过程就是将每个训练样本视为一个状态向量，使其出现的概率尽可能大。标准的Boltzmann机是一个完全图，复杂度很高。现实中常采用首先Boltzmann机(Restricted Boltzmann Machine，简称BRM)，如图5.14(b)，仅保留显层与隐层之间的连接，简化为二部图。 受限Boltzmann机常用”对比散度”)(Contrastive Divergence，简称CD)算法训练。假定网络中有d个显层神经元和q个隐层神经元，令v和h分别表示显层与隐层的状态向量，则由于同一层内不存在连接，有 P(v|h)=\prod_{i=1}^dP(v_i|h), (5.22)\\ P(h|v)=\prod_{j=1}^qP(h_j|v). (5.23)CD算法对每个训练样本，先根据式(5.23)计算出隐层神经元状态的概率分布，然后根据这个概率分布采样得到h；此后，类似地根据式(5.22)从h中产生$v’$，再从$v’$产生$h’$；连接权的更新公式为 \Delta w=\eta(vh^T-v'h'^T). (5.24)5.6 深度学习理论上，参数越多的模型复杂度越高、”容量”(capacity)越大，能完成更复杂的学习任务。因此以”深度学习”(deep learning)为代表的复杂模型开始受到人们关注。 典型的深度学习模型就是很深层的神经网络。提高容量的一个简单办法就是增加隐层数目，然而多隐层难以直接用经典算法进行训练，因为误差在多隐层内逆传播时往往会”发散”(diverge)而不能收敛到稳定状态。 无监督逐层训练(unsupervised layer-wise training)是多隐层网络训练的有效手段，基本思想是每次训练一层隐结点，训练时将上一层隐结点的输出作为输入，而本层隐结点的输出作为下一层隐结点的输入，称为”预训练”(pre-training)；预训练全部完成后，再对整个网络进行”微调”(finetuning)训练。例如在深度信念网络(deep belief network，简称DBN)中，每层都是一个受限Boltzmann机，即整个网络视为若干个RBM堆叠而得。这种做法可视为将参数大量分组，对每组找到局部较优值，再联合起来进行全局寻优。 另一种节省开销的策略是”权共享”(weight sharing)，让一组神经元使用相同的连接权。这个策略在卷积神经网络(Convolutional Neural Network，简称CNN)中发挥重要作用。以CNN手写数字识别任务为例，如图5.15，网络输入是一个$32\times32​$的手写数字图像，输出是识别结果，CNN复合多个”卷积层”和”采样层”对输入信号进行加工，然后在连接层实现与输入目标之间的映射。每个卷积层都包含多个特征映射(feature map)，每个特征映射是一个由多个神经元构成的”平面”，通过一种卷积滤波器提取输入的一种特征。采样层亦称为”汇合”层，其作用是基于局部相关性原理进行亚采样，从而在减少数据量的同时保留有用信息。 从另一个角度理解，无论DBN还是CNN，都是通过多层处理，逐渐将初始的”低层”特征表示转化为”高层”特征表示后，用”简单模型”即可完成复杂的分类等学习任务。由此可将深度学习理解为进行”特征学习”(feature learning)或”表示学习”(representation learning)。]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Poj3461 Oulipo]]></title>
    <url>%2F2019%2F03%2F23%2FPoj3461%2F</url>
    <content type="text"><![CDATA[DescriptionThe French author Georges Perec (1936–1982) once wrote a book, La disparition, without the letter ‘e’. He was a member of the Oulipo group. A quote from the book: Tout avait Pair normal, mais tout s’affirmait faux. Tout avait Fair normal, d’abord, puis surgissait l’inhumain, l’affolant. Il aurait voulu savoir où s’articulait l’association qui l’unissait au roman : stir son tapis, assaillant à tout instant son imagination, l’intuition d’un tabou, la vision d’un mal obscur, d’un quoi vacant, d’un non-dit : la vision, l’avision d’un oubli commandant tout, où s’abolissait la raison : tout avait l’air normal mais… Perec would probably have scored high (or rather, low) in the following contest. People are asked to write a perhaps even meaningful text on some subject with as few occurrences of a given “word” as possible. Our task is to provide the jury with a program that counts these occurrences, in order to obtain a ranking of the competitors. These competitors often write very long texts with nonsense meaning; a sequence of 500,000 consecutive ‘T’ s is not unusual. And they never use spaces.So we want to quickly find out how often a word, i.e., a given string, occurs in a text. More formally: given the alphabet {‘A’, ‘B’, ‘C’, …, ‘Z’} and two finite strings over that alphabet, a word W and a text T, count the number of occurrences of W in T. All the consecutive characters of W must exactly match consecutive characters of T. Occurrences may overlap. InputThe first line of the input file contains a single number: the number of test cases to follow. Each test case has the following format: One line with the word W, a string over {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, …, &#39;Z&#39;}, with 1 ≤ |W| ≤ 10,000 (here |W| denotes the length of the string W). One line with the text T, a string over {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, …, &#39;Z&#39;}, with |W| ≤ |T| ≤ 1,000,000. OutputFor every test case in the input file, the output should contain a single number, on a single line: the number of occurrences of the word W in the text T. Sample Input12345673BAPCBAPCAZAAZAZAZAVERDIAVERDXIVYERDIAN Sample Output123130 AnalysisKMP板题…. 给出两个字符串，其中一个是另一个的子串，求子串P在母串T中出现了多少次。 显然暴力做法是从左到右一个个匹配，如果有某个字符不匹配，就跳回去，把字串右移。当然这是肯定会超时的。 观察发现，当匹配失败时，我们已经知道前面有一些字符是匹配的了，这时仅仅右移一位就显得很笨拙。而KMP的思想是：利用已经部分匹配这个有效信息，保持i指针不回溯，通过修改j指针，让模式串尽量地移动到有效的位置。 所以整个KMP的重点在于：当某一个字符与主串不匹配时，我们应该知道j指针要移动到哪？ 如下图，C和B不匹配了，可以把j移到第2位，因为前面有两个字母是一样的： 可看出，当匹配失败时，j要移动的下一个位置k有这样的性质：最前面的k个字符和j之前的最后k个字符是一样的。 如上图，有公式： P[0\sim k-1]==P[j-k\sim j-1]那么 \begin{aligned} &当T[i]!=P[j]\\ &有T[i-j\sim i-1]==P[0\sim j-1]\\ &由P[0\sim k-1]==P[j-k\sim j-1]\\ &必T[i-k\sim i-1]==P[0\sim k-1] \end{aligned}因为P的每一个位置都可能发生不匹配，所以用一个next数组保存每一个位置j对应的k，next[j]=k，表示当$T[i]!=P[j]$时，j的下一个位置。函数getnext()即为其过程。 对比这两个图发现规律： \begin{aligned} &当P[k]==P[j]\\ &有next[j+1]==next[j]+1 \end{aligned}证明： 因为在P[j]之前已经有P[0\sim k-1]==P[j-k\sim j-1](next[j]==k)。\\ 这时候由P[k]==P[j]，可以得到P[0\sim k-1]+P[k]==P[j-k\sim j-1]+P[j]，即上式。当$P[k]!=P[j]$时，如下图 此时应为$k=next[k]$，如下图 然而上述算法还有点缺陷 如图，这一步移动毫无意义，因为后面的B已经不匹配，那么前面的B肯定也不匹配，原因在于$P[j]==P[next[j]]$。所以在getnext()中特判一下这种情况就ok了。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 1000100;char s1[maxn], s2[maxn];int Next[maxn];int lens1, lens2;int KMP()&#123; int i = 0, j = 0, ans = 0; while (i &lt; lens1&amp;&amp;j &lt; lens2) &#123; if (i == -1 || s1[i] == s2[j]) &#123; i++; j++; &#125; else &#123; i = Next[i]; &#125; if (i == lens1) &#123; ans++; i = Next[i]; &#125; &#125; return ans;&#125;void getnext()&#123; Next[0] = -1; int i = 0, j = -1; while (i &lt; lens1) &#123; if (j == -1 || s1[i] == s1[j]) &#123; i++; j++; if (s1[i] == s1[j])Next[i] = Next[j]; else Next[i] = j; &#125; else &#123; j = Next[j]; &#125; &#125;&#125;int main()&#123; int T; scanf("%d", &amp;T); while (T--) &#123; scanf("%s", s1); scanf("%s", s2); lens1 = strlen(s1); lens2 = strlen(s2); getnext(); int ans = KMP(); printf("%d\r\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>String</category>
        <category>KMP</category>
      </categories>
      <tags>
        <tag>POJ</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Note of Machine Learning 4]]></title>
    <url>%2F2019%2F03%2F21%2FML4%2F</url>
    <content type="text"><![CDATA[第4章 决策树4.1 基本流程决策树(decision tree)是基于树结构进行决策的一种常见机器学习方法。 决策过程的最终结论对应了所希望的判定结果；决策过程中提出的每个判定问题都是对某个属性的”测试”；每个测试或是导出结论，或是导出进一步的判定问题，其考虑范围是在上次决策结果的限定范围之内。 一般的，一棵决策树包含一个根结点、若干个内部结点和若干个叶节点；叶结点对应于决策结果，其他每个结点对应于一个属性测试；每个结点包含的样本集合根据属性测试的结果被划分到子结点中；根结点包含样本全集。从根结点到每个叶结点的路径对应了一个判定测试序列。决策树学习的目的是为了产生一棵泛化能力强的决策树，基本流程遵循”分治”(divide-and-conquer)策略。 4.2 划分选择决策树的关键是如何选择最优划分属性。随着划分过程不断进行，我们希望决策树的分支结点所包含的样本尽可能属于同一类别，即结点的”纯度”(purity)越来越高 4.2.1 信息增益“信息熵”(information entropy)是度量样本集合纯度最常用的一种指标。假定当前样本集合D中第k类样本所占比例为$p_k(k=1,2,\dots,|y|)$，则D的信息熵定义为 Ent(D)=-\sum_{k=1}^{|y|}p_k\log_2p_k. (4.1)$Ent(D)​$的值越小，D的纯度越高。 假定离散属性a有V个可能取值${a^1,a^2,\dots,a^V}$，若使用a来对样本集进行划分，则产生V个分支点，其中第v个分支点包含了D中所有在属性a上取值为$a^v$的样本，记为$D^v$。根据(4.1)计算出$D^v$的信息熵，再考虑到不同的分支结点所包含的样本数不同，于是可计算出用属性a对样本集D进行划分所获得的”信息增益”(information gain) Gain(D,a)=Ent(D)-\sum_{v=1}^V\frac{|D^v|}{|D|}Ent(D^v). (4.2)信息增益越大，意味着使用属性a来进行划分所获得的”纯度提升越大”越大。因此可用信息增益来进行决策树的划分属性选择。即在图4.2算法第8行选择属性$a*={\arg\max}{a\in A}Gain(D,a)$。 以表4.1西瓜数据集为例。数据集包含17个训练样例。$|y|=2$。决策树学习开始时，根结点包含D中所有样例，正例占$p_1=\frac{8}{17}$，反例占$p_2=\frac{9}{17}$。根据式(4.1)算出根结点的信息熵 Ent(D)=-\sum_{k=1}^2p_k\log_2p_k=-(\frac{8}{17}\log_2\frac{8}{17}+\frac{9}{17}\log_2\frac{9}{17})=0.998. 然后计算当前属性集合{色泽，根蒂，敲声，纹理，脐部，触感}中每个属性的信息增益。以色泽为例，使用该属性对D进行划分，可得到三个子集。根据式(4.1)分别计算出用色泽划分之后所获得的三个分支结点的信息熵为 Ent(D^1)=-(\frac{3}{6}\log_2\frac{3}{6}+\frac{3}{6}\log_2\frac{3}{6})=1.000,\\ Ent(D^2)=-(\frac{4}{6}\log_2\frac{4}{6}+\frac{2}{6}\log_2\frac{2}{6})=0.918,\\ Ent(D^3)=-(\frac{1}{5}\log_2\frac{1}{5}+\frac{4}{5}\log_2\frac{4}{5})=0.722,\\于是根据式(4.2)计算属性色泽的信息增益为 \begin{aligned} Gain(D,色泽)&=End(D)-\sum_{v=1}^3\frac{|D^v|}{|D|}Ent(D^v)\\ &=0.998-(\frac{6}{17}\times1.000+\frac{6}{17}\times0.918+\frac{5}{17}\times0.722)\\ &=0.109. \end{aligned}类似的，可计算出其他属性的信息增益。选择信息增益最大的属性作为划分属性。然后决策树学习算法将对每个分支点做进一步划分，最终得到的决策树如图4.4所示。 4.2.2 增益率若把表4.1中的编号也作为一个候选划分属性，则其信息增益远大于其他候选划分属性。这样的决策树显然不具有泛化能力，实际上信息增益准则对可取值数目较多的属性有所偏好，为减少这种偏好可能带来的不利影响，可以使用”增益率”(gain ratio)来选择最优划分属性。采用与式(4.2)相同的符号表示，增益率定义为 Gain\_ratio(D,a)=\frac{Gain(D,a)}{IV(a)}, (4.3)其中 IV(a)=-\sum_{v=1}^V\frac{|D^v|}{|D|}\log_2\frac{|D^v|}{|D|} (4.4)称为属性a的”固有值”(intrinsic value)。属性a的可能取值数目越多(即V越大),IV(a)的值通常会越大。增益率准则对可取值数目较少的属性有所偏好，因此C4.5算法使用了一个启发式：先从候选划分属性中找出信息增益高于平均水平的属性，再从中选择增益率最高的。 4.2.3 基尼指数CART决策树使用”基尼指数”(Gini index)来选择划分属性。采用与式(4.1)相同的符号，数据集D的纯度可用基尼值来度量： \begin{aligned} Gini(D)&=\sum_{k=1}^{|y|}\sum_{k'\neq k}p_kp_{k'}\\ &=1-\sum_{k=1}^{|y|}p_k^2. (4.5) \end{aligned}Gini(D)反映了从数据集D中随机抽取两个样本，其类别标记不一致的概率。因此Gini(D)越小，则数据集D的纯度越高。采用与式(4.2)相同的符号表示，属性a的基尼指数定义为 Gini\_index(D,a)=\sum_{v=1}^V\frac{|D^v|}{|D|}Gini(D^v). (4.6)于是，在候选属性集合A中，选择那个使得划分后基尼指数最小的属性作为最优划分属性，即$a*={\arg\min}{a\in A}Gini_index(D,a)$。 4.3 剪枝处理剪枝(pruning)是决策树学习算法对付”过拟合”的主要手段。决策树剪枝的基本策略有”预剪枝”(prepruning)和”后剪枝”(postpruning)。预剪枝是在决策树生成过程中，对每个结点在划分前先进行估计，若当前结点的划分不能带来决策树泛化性能提升则停止划分并将当前结点标记为叶结点；后剪枝先从训练集生成一棵完整的决策树，然后自底向上地对非叶结点进行考察，若将该结点对应的子树替换为叶结点能带来泛化性能提升，则为之。本节使用留出法进行判断泛化性能是否提升的标准。将表4.1随机划分为两部分变为表4.2，上为训练集下为测试集。 采用信息增益准则进行划分属性选择，生成一棵如图4.5的决策树。 4.3.1 预剪枝基于预剪枝策略从表4.2数据所生成的决策树如图4.6所示，其测试集精度为71.4%。这是一棵仅有一层划分的决策树，亦称”决策树桩”(decision stump)。预剪枝降低了过拟合风险，减少了时间开销，却带来了欠拟合的风险。 4.3.2 后剪枝后剪枝先基于表4.2生成如图4.5的决策树，其测试集精度为42.9%。然后依次考察每个结点，若将其领衔的子树替换为叶结点后测试集精度提升，则剪枝。最后生成如图4.7的决策树，其测试集精度为71.4%。后剪枝欠拟合风险很小，泛化性能往往优于预剪枝，但时间开销大。 4.4 连续与缺失值4.4.1 连续值处理现实学习任务中属性取值不一定离散，可能为连续值。处理连续值最简单的策略是二分法。 给定样本集D和连续属性a，假定a在D上出现了n个不同取值，将这些值从小到大进行排序。基于划分点t将D分为子集$D^-_t$和$D^+_t$，前者包含在属性a上取值不大于t的样本，后者反之。对相邻的属性取值$a^i,a^{i+1}$来说，t在区间$[a^i,a^{i+1})$中取任意值所产生的划分结果相同。因此对连续属性a，考察包含n-1个元素的候选划分点集合 T_a=\{\frac{a^i+a^{i+1}}{2}|1\leq i\leq n-1\}, (4.7)然后像考虑离散值一样考虑这些划分点 \begin{aligned} Gain(D,a)&=\max_{t\in T_a}Gain(D,a,t)\\ &=\max_{t\in T_a}Ent(D)-\sum_{\lambda\in\{-,+\}}\frac{|D^\lambda_t|}{|D|}Ent(D^\lambda_t), (4.8) \end{aligned}例如，在表4.1的数据集上增加两个连续属性得到表4.3，来生成一棵决策树。对属性”密度”，由式(4.8)计算出信息增益0.262，对应于划分点0.381。对属性”含糖率”，计算出信息增益0.349，对应于划分点0.126。 与离散属性不同的是，若当前结点划分属性为连续属性，该属性还可作为其后代结点的划分属性。 4.4.2 缺失值处理现实学习任务中可能遇到样本的某些属性值缺失，如表4.4。 此时面临两个问题：(1)如何在属性值缺失的情况下进行划分属性选择。(2)给定划分属性，若样本在该属性上的值缺失，如何对样本进行划分。 给定训练集D和属性a，令$\tilde{D}$表示D中在属性a上没有缺失值的样本子集。对问题(1)，仅可根据$\tilde{D}$来判断属性a的优劣。假定属性a有V个可取值，令$\tilde{D}^v$表示$\tilde{D}$在属性a上取值为$a^v$的样本子集，$\tilde{D}k$表示$\tilde{D}$中属于第k类的样本子集，显然有$\tilde{D}=\bigcup^{|y|}{k=1}\tilde{D}k,\tilde{D}=\bigcup^V{v=1}\tilde{D}^v$。假定为每个样本x赋予一个权重$w_x$，并定义 \rho=\frac{\sum_{x\in\tilde{D}}w_x}{\sum_{x\in D}w_x}, (4.9)\\ \tilde{p}_k=\frac{\sum_{x\in\tilde{D}_k}w_x}{\sum_{x\in\tilde{D}}w_x}(1\leq k\leq|y|), (4.10)\\ \tilde{r}_v=\frac{\sum_{x\in\tilde{D}^v}w_x}{\sum_{x\in\tilde{D}}w_x}(1\leq v\leq V). (4.11)其中$\rho$表示无缺失值样本所占的比例，$\tilde{p}k$表示无缺失值样本中第k类所占的比例，$\tilde{r}^v$表示无缺失值样本中在属性a上取值$a^v$的样本所占的比例。显然，$\sum{k=1}^{|y|}\tilde{p}k=1,\sum{v=1}^V\tilde{r}_v=1$。 基于上述定义将式(4.2)推广为 \begin{aligned} Gain(D,a)&=\rho\times Gain(\tilde{D},a)\\ &=\rho\times(Ent(\tilde{D})-\sum_{v=1}^V\tilde{r}_vEnt(\tilde{D}^v)), (4.12) \end{aligned}其中由式(4.1)，有 Ent(\tilde{D})=-\sum_{k=1}^{|y|}\tilde{p}_k\log_2\tilde{p}_k.对问题(2)，若样本x在划分属性a上的取值已知，则将x划入与其取值对应的子结点，且样本权值保持不变。否则，将x同时划入所有子结点，样本权值在与属性值$a^v$对应的子结点中调整为$\tilde{r}_v\cdot w_x$。以表4.4的数据集为例生成了如图4.9所示的决策树。 4.5 多变量决策树把每个属性视为坐标空间中的一个坐标轴，d个属性描述的样本对应了d维空间中的一个数据点，对样本分类则意味着在这个坐标空间中寻找不同类样本之间的分类边界。决策树形成的分类边界有明显的轴平行(axis-parallel)特点。以表4.5为数据集，学得图4.10所示决策树，其分类边界如图4.11 但在学习任务的真实分类边界比较复杂时，如图4.12所示，时间开销会很大。 此时可如图4.12中红色线段所示使用斜的划分边界，即使用”多变量决策树”(multivariate decision tree)或”斜决策树”(oblique decision tree)。与传统的”单变量决策树”(univariate decision tree)不同，多变量决策树学习过程中，不是为每个非叶结点寻找一个最优划分属性，而是试图建立一个合适的线性分类器。例如对表4.5数据集，可学得图4.13的多变量决策树，其分类边界如图4.14.]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[100-Days-Of-ML-Code Day6 逻辑回归]]></title>
    <url>%2F2019%2F03%2F12%2F100%E5%A4%A9ML-6%2F</url>
    <content type="text"><![CDATA[逻辑回归|第6天Steps Datasets 数据集包含了社交网络中用户的信息。这些信息涉及用户ID,性别,年龄以及预估薪资。一家汽车公司刚刚推出了他们新型的豪华SUV，尝试预测哪些用户会购买这种全新SUV。并且在最后一列用来表示用户是否购买。将建立一种模型来预测用户是否购买这种SUV，该模型基于两个变量，分别是年龄和预计薪资。因此特征矩阵将是这两列。我们尝试寻找用户年龄与预估薪资之间的某种相关性，以及他是否购买SUV的决定。 Code第1步：数据预处理12345678910111213141516#导入库import numpy as npimport matplotlib.pyplot as pltimport pandas as pd#导入数据集dataset = pd.read_csv('Social_Network_Ads.csv')X = dataset.iloc[:,[2,3]].valuesY = dataset.iloc[:,4].values#将数据集分成训练集和测试集from sklearn.model_selection import train_test_splitX_train,X_test,Y_train,Y_test = train_test_split(X,Y,test_size = 0.25,random_state = 0)#特征缩放from sklearn.preprocessing import StandardScalersc = StandardScaler()X_train = sc.fit_transform(X_train)X_test = sc.transform(X_test) 第2步：逻辑回归模型该项工作的库将会是一个线性模型库，之所以被称为线性是因为逻辑回归是一个线性分类器，这意味着在二维空间中，两类用户（购买和不购买）将被一条直线分割。然后导入逻辑回归类。下一步将创建该类的对象，它将作为训练集的分类器。 1234#将逻辑回归应用于训练集from sklearn.linear_model import LogisticRegressionclassifier = LogisticRegression()classifier.fit(X_train, Y_train) 第3步：预测12#预测测试集结果Y_pred=classifier.predict(X_test) 第四步：评估预测预测了测试集。 现在将评估逻辑回归模型是否正确的学习和理解。因此这个混淆矩阵将包含模型的正确和错误的预测。 12345#生成混淆矩阵from sklearn.metrics import confusion_matrixcm = confusion_matrix(Y_test,Y_pred)#用来呈现算法性能的效果的特定矩阵#混淆矩阵的每一列代表了预测类别,每一列的总数表示预测为该类别的数据的数目；每一行代表了数据的真实归属类别,每一行的数据总数表示该类别的数据实例的数 训练集可视化123456789101112131415from matplotlib.colors import ListedColormapX_set,Y_set = X_train,Y_trainX1,X2 = np.meshgrid(np.arange(start = X_set[:,0].min() - 1,stop = X_set[:,0].max() + 1,step = 0.01),np.arange(start = X_set[:,1].min() - 1,stop = X_set[:,1].max() + 1,step = 0.01))#meshgrid(x,y)根据向量x,y生成网格点坐标矩阵，arange()根据参数范围生成向量plt.contourf(X1,X2,classifier.predict(np.array([X1.ravel(),X2.ravel()]).T).reshape(X1.shape),alpha = 0.75,cmap = ListedColormap(('red','green')))#contourf()绘制三维等高线图在二维空间的投影并进行区域填充,ravel()将多维数组降为一维plt.xlim(X1.min(),X1.max())plt.ylim(X2.min(),X2.max())for i,j in enumerate(np.unique(Y_set)): plt.scatter(X_set[Y_set == j,0],X_set[Y_set == j,1],c = ListedColormap(('black','white'))(i),label = j)plt.title('Logistic Regression(Training set)')plt.xlabel('Age')plt.ylabel('Estimated Salary')plt.legend()#显示图中标签plt.show() 测试集可视化123456789101112X_set,Y_set=X_test,Y_predX1,X2 = np.meshgrid(np.arange(start = X_set[:,0].min() - 1,stop = X_set[:,0].max() + 1,step = 0.01),np.arange(start = X_set[:,1].min() - 1,stop = X_set[:,1].max() + 1,step = 0.01))plt.contourf(X1,X2,classifier.predict(np.array([X1.ravel(),X2.ravel()]).T).reshape(X1.shape),alpha = 0.75,cmap = ListedColormap(('red','green')))plt.xlim(X1.min(),X1.max())plt.ylim(X2.min(),X2.max())for i,j in enumerate(np.unique(Y_set)): plt.scatter(X_set[Y_set == j,0],X_set[Y_set == j,1],c = ListedColormap(('black','white'))(i),label = j)plt.title('Logistic Regression(Test set)')plt.xlabel('Age')plt.ylabel('Estimated Salary')plt.legend()plt.show()]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hdu3555 Bomb]]></title>
    <url>%2F2019%2F03%2F11%2FHdu3555%2F</url>
    <content type="text"><![CDATA[DescriptionThe counter-terrorists found a time bomb in the dust. But this time the terrorists improve on the time bomb. The number sequence of the time bomb counts from 1 to N. If the current number sequence includes the sub-sequence “49”, the power of the blast would add one point.Now the counter-terrorist knows the number N. They want to know the final points of the power. Can you help them? InputThe first line of input consists of an integer $T (1 \leq T \leq 10000)$, indicating the number of test cases. For each test case, there will be an integer $N (1 \leq N \leq 2^{63}-1)$ as the description. The input terminates by end of file marker. OutputFor each test case, output an integer indicating the final points of the power. Sample Input12343150500 Sample Output1230115 Analysis数位DP的模板题。题意是给出数N，求1到N内包含数字”49”的数的个数。 将数N按从低位到高位的顺序逐位存储在数组a中，从最高位开始往最低位搜索。 解释一下搜索的函数 1ll dfs(int pos, bool state, bool limit) pos表示当前dfs正在搜索的数位，state存储了搜索的前一位是不是”4”，如果true则表明是”4”，limit表示当前位是否存在最高位，例如1275，在前面为12时第三位最高只能取7，但是前面为11时第三位就可以取1到9，这时就需要用limit判断它否取到9。因为从最高位开始搜索，所以一开始传入limit为true。 这里用dp[20][2]来记忆化搜索结果，其中dp[i][0]表示搜索的前一位不是”4”的情况下，当前位有多少取法使其不含”49”，而dp[i][1]表示前一位是”4”的情况下，当前位有多少种取法使其不含”49”。 最后搜索出的结果是从0到N中不包含”49”的数字的个数，显然0是不包含的，所以要求1到N内包含”49”的数的个数的最终的结果应该是 1N-solve(N)+1 代码如下。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;int T;ll N;int a[20];ll dp[20][2];int sum = 0;ll dfs(int pos, bool state, bool limit)&#123; if (pos == 0) return 1; if (!limit&amp;&amp;dp[pos][state]) return dp[pos][state]; int up = (limit ? a[pos] : 9); ll cnt = 0; for (int i = 0; i &lt;= up; i++) &#123; if (state &amp;&amp; (i == 9)) continue; cnt += dfs(pos - 1, i == 4, limit &amp;&amp; (i == up)); &#125; if (limit) return cnt; else &#123; dp[pos][state] = cnt; return cnt; &#125;&#125;ll solve(ll n)&#123; int i = 0; while (n) &#123; a[++i] = n % (ll)10; n /= (ll)10; &#125; return dfs(i, false, true);&#125;int main()&#123; memset(a, 0, sizeof(a)); memset(dp, 0, sizeof(dp)); cin &gt;&gt; T; while (T-- != 0) &#123; cin &gt;&gt; N; cout &lt;&lt; N - (solve(N) - solve(0)) &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Dynamic Programming</category>
        <category>Digital Dynamic Programming</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Note of Machine Learning 3]]></title>
    <url>%2F2019%2F03%2F10%2FML3%2F</url>
    <content type="text"><![CDATA[第3章 线性模型3.1 基本形式线性模型(linear model)试图学得一个通过属性的线性组合来进行预测的函数，即 f(x)=w_1x_1+w_2x_2+\dots+w_dx_d+b, (3.1)一般用向量形式写成 f(x)=w^Tx+b, (3.2)w和b学得之后模型得以确定。许多功能强大的非线性模型(nonlinear model)可在线性模型的基础上通过引入层级结构或高维映射而得。由于w直观表达了各属性在预测中的重要性，因此线性模型有很好的可解释性(comprehensibility) or 可理解性(understandability)。 3.2 线性回归“线性回归”(linear regression)试图学得一个线性模型以尽可能准确地预测实值输出标记。 对离散属性，若属性值存在”序”(order)关系，可通过连续化将其转化为连续值；若属性值间不存在序关系，假设有k个属性值，则通常转化为k维向量。 线性回归试图学得 f(x_i)=wx_i+b,使得f(x_i)\simeq y_i. (3.3)2.3介绍过，均方误差(2.2)是回归任务中最常用的性能度量，可试图让均方误差最小化： \begin{aligned} (w^*,b^*)&={\arg\min}_{(w,b)}\sum_{i=1}^m(f(x_i)-y_i)^2\\ &={\arg\min}_{(w,b)}\sum_{i=1}^m(y_i-wx_i-b)^2. (3.4) \end{aligned}均方误差的几何意义对应了”欧式距离”(Euclidean distance)。基于均方误差最小化来进行模型求解的方法称为”最小二乘法”(least square method)。求解并使$E{(w,b)}=\sum{i=1}^m(y_i-wx_i-b)^2$最小化的过程称为线性回归模型的最小二乘”参数估计”(parameter estimation)。可分别对w和b求导，得到 \frac{\partial E_{(w,b)}}{\partial w}=2(w\sum_{i=1}^mx_i^2-\sum_{i=1}^m(y_i-b)x_i), (3.5)\\ \frac{\partial E_{(w,b)}}{\partial b}=2(mb-\sum_{i=1}^m(y_i-wx_i)), (3.6)然后令式(3.5)和(3.6)为零可得到w和b最优解的闭式(closed-form)解 w=\frac{\sum_{i=1}^my_i(x_i-\bar{x})}{\sum_{i=1}^mx_i^2-\frac{1}{m}(\sum_{i=1}^mx_i)^2}, (3.7)\\ b=\frac{1}{m}\sum_{i=1}^m(y_i-wx_i), (3.8)其中$\bar{x}=\frac{1}{m}\sum_{i=1}^mx_i$为x的均值。 若数据集样本由d个属性描述，试图学得$f(x_i)=w^Tx_i+b,使得f(x_i)\simeq y_i,$这称为”多元线性回归”(multivariate linear regression)。 把w和b吸收入向量形式$\hat{w}=(w;b)$，把数据集D表示为一个$m\times(d+1)$的矩阵X，每行为一个示例，前d个元素为d个属性值，最后一个元素置1： X= \left( \begin{matrix} x_{11}&x_{12}&\dots&x_{1d}&1\\ x_{21}&x_{22}&\dots&x_{2d}&1\\ \vdots&\vdots&\ddots&\vdots&\vdots\\ x_{m1}&x_{m2}&\dots&x_{md}&1 \end{matrix} \right)= \left( \begin{matrix} x_1^T&1\\ x_2^T&1\\ \vdots&\vdots\\ x_m^T&1 \end{matrix} \right),再把标记也写成向量形式$y=(y_1;y_2;\dots;y_m)$，则类似于(3.4)有 \hat{w}^*={\arg\min}_{\hat{w}}(y-X\hat{w})^T(y-X\hat{w}). (3.9)令$E_{\hat{w}}=(y-X\hat{w})^T(y-X\hat{w})$,对$\hat{w}$求导得到 \frac{\partial E_{\hat{w}}}{\partial\hat{w}}=2X^T(X\hat{w}-y). (3.10)令上式为零可得$\hat{w}$最优解的闭式解。 当$X^TX$为满秩矩阵(full-rank matrix)或正定矩阵(positive definite matrix)时，令(3.10)为零可得 \hat{w}^*=(X^TX)^{-1}X^Ty, (3.11)令$\hat{x}_i=(x_i;1)$,则最终学得的多元线性回归模型为 f(\hat{x}_i)=\hat{x}_i^T(X^TX)^{-1}X^Ty. (3.12)然而现实中矩阵往往不满秩，解出多个$\hat{w}$时常见做法是引入正则化(regularization)项。 将线性回归模型写为 \ln y=w^Tx+b. (3.14)这就是”对数线性回归”(log-linear regression)。更一般地，考虑单调可微函数$g(\cdot)$，令 y=g^{-1}(w^Tx+b), (3.15)这样得到的模型称为”广义线性模型”(generalized linear model)，其中函数$g(\cdot)$称为”联系函数”(link function)。 3.3 对数几率回归若要做的是分类任务，只需找一个单调可微函数将分类任务的真实标记y与线性回归模型的预测值联系起来。考虑二分类任务，线性回归模型产生的预测值是实值，需将实值转换为0/1值。最理想的是”单位阶跃函数”(unit-step function) y= \left\{ \begin{array}{} 0, z0, \end{array} \right. (3.16)但单位阶跃函数不连续，所以用对数几率函数(logistic function)作为其”替代函数”(surrogate function): y=\frac{1}{1+e^{-z}}. 对数几率函数是一种”Sigmoid函数”，将其代入(3.15)得到 y=\frac{1}{1+e^{-(w^Tx+b)}}. (3.18)类似于(3.14),(3.18)可变化为 \ln\frac{y}{1-y}=w^T+b. (3.19)若将y视为样本x作为正例的可能性，则1-y是其反例可能性，两者的比值 \frac{y}{1-y} (3.20)称为”几率”(odds)，反映了x作为正例的相对可能性。对几率取对数则得到”对数几率”(log odds,logit) \ln\frac{y}{1-y}. (3.21)此模型称为”对数几率回归”(logistic regression,logit regression)，实际上是一种分类学习方法。优点在于直接对分类可能性进行建模，避免了假设分布不准确所带来的问题。 若将(3.18)中的y视为类后验概率估计$p(y=1|x)$，则(3.19)重写为 \ln\frac{p(y=1|x)}{p(y=0|x)}=w^Tx+b. (3.22)显然有 p(y=1|x)=\frac{e^{w^Tx+b}}{1+e^{w^Tx+b}}, (3.23)\\ p(y=0|x)=\frac{1}{1+e^{w^Tx+b}}, (3.24)可通过”极大似然法(maximum likelihood method)”来估计w和b。给定数据集，对率回归模型最大化”对数似然”(loglikehood) \ell(w,b)=\sum_{i=1}^m\ln p(y_i|x_i;w,b), (3.25)令$\beta=(w;b),\hat{x}=(x;1)$，则$w^Tx+b$可简写为$\beta^T\hat{x}$。再令$p_1(\hat{x};\beta)=p(y=1|\hat{x};\beta),p_0(\hat{x};\beta)=p(y=0|\hat{x};\beta)=1-p_1(\hat{x};\beta)$，则(3.25)中的似然项可重写为 p(y_i|x_i;w,b)=y_ip_1(\hat{x}_i;\beta)+(1-y_i)p_0(\hat{x}_i;\beta). (3.26)将(3.26)代入(3.25)，并根据(3.23)和(3.24)可知，最大化(3.25)等价于最小化 \ell(\beta)=\sum_{i=1}^m(-y_i\beta^T\hat{x}_i+\ln(1+e^{\beta T\hat{x}_i})). (3.27)(3.27)是关于$\beta$的高阶可导连续凸函数，可有梯度下降法(gradient descent method)、牛顿法(Newton method)等求其最优解，得到 \beta^*={\arg\min}_\beta\ell(\beta). (3.28)以牛顿法为例，第t+1轮迭代解的更新公式为 \beta^{t+1}=\beta^t-(\frac{\partial^2\ell(\beta)}{\partial\beta\partial\beta^T})^{-1}\frac{\partial\ell(\beta)}{\partial\beta}, (3.29)其中关于$\beta$的一阶、二阶导数分别为 \frac{\partial\ell(\beta)}{\partial\beta}=-\sum_{i=1}^m\hat{x}_i(y_i-p_1(\hat{x}_i;\beta)), (3.30)\\ \frac{\partial^2\ell(\beta)}{\partial\beta\partial\beta^T}=\sum_{i=1}^m\hat{x}_i\hat{x}_i^Tp_1(\hat{x}_i;\beta)(1-p_1(\hat{x}_i;\beta)). (3.31)3.4 线性判别分析线性判别分析(Linear Discriminant Analysis,简称LDA)，亦称”Fisher判别分析”。给定训练样例集，将样例投影到一条直线上，使同类样例投影点尽可能接近、异类样例投影点尽可能远离；在对新样本进行分类时，将其投影到同样的这条直线上，再根据投影点的位置来确定新样本的类别。 给定数据集$D={(xi,y_i)}{i=1}^m,y_i\in{0,1}​$，令$X_i、\mu_i、\Sigma_i​$分别表示第$i\in{0,1}​$类示例的集合、均值向量、协方差矩阵。两类样本的中心在直线上的投影分别为$w^T\mu_0​$和$w^T\mu_1​$；协方差分别为$w^T\Sigma_0w​$和$w^T\Sigma_1w​$，它们均为实数。 欲使同类样例的投影点尽可能接近，可以让同类样例投影点的协方差$w^T\Sigma_0w+w^T\Sigma_1w​$尽可能小；欲使异类样例的投影点尽可能远离，可以让类中心之间的距离$||w^T\mu_0-w^T\mu_1||_2^2​$尽可能大。同时考虑二者得到欲最大化的目标 \begin{aligned} J&=\frac{||w^T\mu_0-w^T\mu_1||_2^2}{w^T\Sigma_0w+w^T\Sigma_1w}\\ &=\frac{w^T(\mu_0-\mu_1)(\mu_0-\mu_1)^Tw}{w^T(\Sigma_0+\Sigma_1)w}. (3.32) \end{aligned}定义”类内散度矩阵”(within-class scatter matrix) \begin{aligned} S_w&=\Sigma_0+\Sigma_1\\ &=\sum_{x\in X_0}(x-\mu_0)(x-\mu_0)^T+\sum_{x\in X_1}(x-\mu_1)(x-\mu_1)^T (3.33) \end{aligned}以及”类间散度矩阵”(between-class scatter matrix) S_b=(\mu_0-\mu_1)(\mu_0-\mu_1)^T, (3.34)则(3.32)可重写为 J=\frac{w^TS_bw}{w^Ts_ww}. (3.35)这就是LDA欲最大化的目标，即$S_b​$与$S_w​$的”广义瑞利商”(generalized Rayleigh quotient)。令$w^TS_ww=1​$，则(3.35)等价于 \begin{aligned} &\min_w-w^TS_bw (3.36)\\ &s.t. w^TS_ww=1. \end{aligned}由拉格朗日乘子法，上式等价于 S_bw=\lambda S_ww, (3.37)其中$\lambda$是拉格朗日乘子。注意到$S_bw$的方向恒为$\mu_0-\mu_1$，不妨令 S_bw=\lambda(\mu_0-\mu_1), (3.38)代入(3.37)得 w=S_w^{-1}(\mu_0-\mu_1). (3.39)实践中通常使$S_w=U\Sigma V^T$进行奇异值分解，$\Sigma$是一个实对角矩阵，对角线上的元素是$S_w$的奇异值，再由$S_w^{-1}=V\Sigma^{-1}U^T$得到$S_w^{-1}$。 将LDA推广到多分类任务中。假定存在N个类，且第i类示例数为$m_i$。先定义”全局散度矩阵” \begin{aligned} S_t&=S_b+S_w\\ &=\sum_{i=1}^m(x_i-\mu)(x_i-\mu)^T, (3.40) \end{aligned}$\mu$是所有示例的均值向量。将类内散度矩阵$S_w$重定义为每个类别的散度矩阵之和，即 S_w=\sum_{i=1}^NS_{w_i}, (3.41)其中 S_{w_i}=\sum_{x\in X_i}(x-\mu_i)(x-\mu_i)^T. (3.42)由式(3.40)~(3.42)可得 \begin{aligned} S_b&=S_t-S_w\\ &=\sum_{i=1}^Nm_i(\mu_i-\mu)(\mu_i-\mu)^T. (3.43) \end{aligned}LDA可使用$S_b,S_w,S_t$中任意两个实现，常见的一种是采用优化目标 \max_W\frac{tr(W^TS_bW)}{tr(W^TS_wW)}, (3.44)其中$W\in\mathbb{R}^{d\times(N-1)},tr(\cdot)$表示矩阵的迹(trace)。上式可通过如下广义特征值问题求解： S_bW=\lambda S_wW. (3.45)W的闭式解则是$S_w^{-1}S_b$的d’个最大非零广义特征值所对应的特征向量组成的矩阵，$d’\leq N-1$。 若将$W$视为投影矩阵，则样本投影到d’维空间，d‘通常远小于原有属性数d，可通过这个投影来减小样本点的维数。 3.5 多分类学习可利用二分类学习器解决多分类问题。多分类学习的基本思路是”拆解法”，将多分类任务拆为若干个二分类任务求解。最经典的拆分策略有三种：”一对一”(One vs. One,OvO)、”一对其余”(One vs. Rest,OvR)和”多对多”(Many vs.Many,MvM)。 给定数据集$D={(x_1,y_1),(x_2,y_2),\dots,(x_m,y_m)},y_i\in{C_1,C_2,\dots,C_N}$。OvO将N个类两两配对产生N(N-1)/2个二分类任务，OvR每次将一个类的样例作为正例、所有其他类的样例作为反例训练N个分类器。两者各有优劣。 MvM的正、反类构造不能随意选取。”纠错输出码”(Error Correcting Output Codes,ECOC)是将编码的思想引入类别拆分，并且在解码过程中具有容错性的MvM技术。主要分为两步： 类别划分通过”编码矩阵(coding matrix)”指定。常见的编码矩阵有二元码和三元码，前者将每个类别分别指定为正类和反类，后者还可指定”停用类”。 测试阶段ECOC编码对分类器的错误有一定的容忍和修正能力。 3.6 类别不平衡问题类别不平衡(class-imbalance)就是指分类任务中不同类别的训练样例数目差别很大的情况。当训练集中正、反例的数目不同时，令$m^+$表示正例数目，$m^-$表示反例数目，则观测几率是$\frac{m^+}{m^-}$，由于通常假设训练集是真实样本总体的无偏采样，因此观测几率就代表了真实几率。于是 若\frac{y}{1-y}>\frac{m^+}{m^-}则预测为正例. (3.47)只需令 \frac{y'}{1-y'}=\frac{y}{1-y}\times\frac{m^-}{m^+}. (3.48)这就是类别不平衡学习的一个基本策略”再缩放”(rescaling)。 再缩放有三类做法：”欠采样”(undersampling)，去除一些反例；”过采样”(oversampling)，增加一些正例；直接基于原始训练集进行学习，在用分类器进行预测时，将(3.48)嵌入决策过程，称为”阀值移动”(threshold-moving)。 “再缩放”也是”代价敏感学习”(cost-sensitive learning)的基础。]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[100-Days-Of-ML-Code Day3 多元线性回归]]></title>
    <url>%2F2019%2F03%2F07%2F100%E5%A4%A9ML-3%2F</url>
    <content type="text"><![CDATA[多元线性回归|第3天Steps 通俗点讲就是有好多好多个X决定一个Y。 Datasets R&amp;D Spend Administration Marketing Spend State Profit 0 165349.20 136897.80 471784.10 New York 192261.83 1 162597.70 151377.59 443898.53 California 191792.06 2 153441.51 101145.55 407934.54 Florida 191050.39 3 144372.41 118671.85 383199.62 New York 182901.99 4 142107.34 91391.77 366168.42 Florida 166187.94 5 131876.90 99814.71 362861.36 New York 156991.12 6 134615.46 147198.87 127716.82 California 156122.51 7 130298.13 145530.06 323876.68 Florida 155752.60 8 120542.52 148718.95 311613.29 New York 152211.77 9 123334.88 108679.17 304981.62 California 149759.96 10 101913.08 110594.11 229160.95 Florida 146121.95 11 100671.96 91790.61 249744.55 California 144259.40 12 93863.75 127320.38 249839.44 Florida 141585.52 13 91992.39 135495.07 252664.93 California 134307.35 14 119943.24 156547.42 256512.92 Florida 132602.65 15 114523.61 122616.84 261776.23 New York 129917.04 16 78013.11 121597.55 264346.06 California 126992.93 17 94657.16 145077.58 282574.31 New York 125370.37 18 91749.16 114175.79 294919.57 Florida 124266.90 19 86419.70 153514.11 0.00 New York 122776.86 20 76253.86 113867.30 298664.47 California 118474.03 21 78389.47 153773.43 299737.29 New York 111313.02 22 73994.56 122782.75 303319.26 Florida 110352.25 23 67532.53 105751.03 304768.73 Florida 108733.99 24 77044.01 99281.34 140574.81 New York 108552.04 25 64664.71 139553.16 137962.62 California 107404.34 26 75328.87 144135.98 134050.07 Florida 105733.54 27 72107.60 127864.55 353183.81 New York 105008.31 28 66051.52 182645.56 118148.20 Florida 103282.38 29 65605.48 153032.06 107138.38 New York 101004.64 30 61994.48 115641.28 91131.24 Florida 99937.59 31 61136.38 152701.92 88218.23 New York 97483.56 32 63408.86 129219.61 46085.25 California 97427.84 33 55493.95 103057.49 214634.81 Florida 96778.92 34 46426.07 157693.92 210797.67 California 96712.80 35 46014.02 85047.44 205517.64 New York 96479.51 36 28663.76 127056.21 201126.82 Florida 90708.19 37 44069.95 51283.14 197029.42 California 89949.14 38 20229.59 65947.93 185265.10 New York 81229.06 39 38558.51 82982.09 174999.30 California 81005.76 40 28754.33 118546.05 172795.67 California 78239.91 41 27892.92 84710.77 164470.71 Florida 77798.83 42 23640.93 96189.63 148001.11 California 71498.49 43 15505.73 127382.30 35534.17 New York 69758.98 44 22177.74 154806.14 28334.72 California 65200.33 45 1000.23 124153.04 1903.93 New York 64926.08 46 1315.46 115816.21 297114.46 Florida 49490.75 47 0.00 135426.92 0.00 California 42559.73 48 542.05 51743.15 0.00 New York 35673.41 49 0.00 116983.80 45173.06 California 14681.40 Code第1步：数据预处理123456789101112131415161718#导入库import pandas as pdimport numpy as np#导入数据集dataset = pd.read_csv('50_Startups.csv')X = dataset.iloc[:,:-1].valuesY = dataset.iloc[:,4].values#将类别数据数字化from sklearn.preprocessing import LabelEncoder,OneHotEncoderlabelencoder = LabelEncoder()X[:,3] = labelencoder.fit_transform(X[:,3])onehotencoder = OneHotEncoder(categorical_features = [3])X = onehotencoder.fit_transform(X).toarray()#躲避虚拟变量陷阱X = X[:,1:]#拆分数据集为训练集和测试集from sklearn.model_selection import train_test_splitX_train,X_test,Y_train,Y_test = train_test_split(X,Y,test_size = 0.2,random_state = 0) 第2步：在训练集上训练多元线性回归模型123from sklearn.linear_model import LinearRegressionregressor = LinearRegression()regressor.fit(X_train,Y_train) 第3步：在测试集上预测结果1Y_pred = regressor.predict(X_test) 多元线性回归可视化几经探索后惨遭失败QAQ。]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1090 合并果子]]></title>
    <url>%2F2019%2F03%2F06%2F%E6%B4%9B%E8%B0%B7P1090%2F</url>
    <content type="text"><![CDATA[Description在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。 每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 n-1次合并之后， 就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。 因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 1，并且已知果子的种类 数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。 例如有3种果子，数目依次为1，2，9。可以先将1 、2堆合并，新堆数目为3，耗费体力为3。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为12 ，耗费体力为12。所以多多总共耗费体力=3+12=15。可以证明15为最小的体力耗费值。 Input共两行。第一行是一个整数$n(1\leq n\leq10000)$，表示果子的种类数。 第二行包含n个整数，用空格分隔，第i个整数$a_i(1\leq a_i\leq20000)$是第i种果子的数目。 Output一个整数，也就是最小的体力耗费值。输入数据保证这个值小于$2^{31}$。 Sample Input123 1 2 9 Sample Output115 Analysis看似是道水题，贪心每次选最小的两组即可，但是一写发现每次选完都要排序，肯定会T。于是想到用优先队列维护一下，刚好我也不会优先队列，就写个博客吧23333. 顺便贴个优先队列的相关知识，转自OI Wiki。 priority_queue12345678910111213141516171819202122#include &lt;queue&gt; // std::priority_queue// 本文里的所有优先队列都会加上命名空间// 如果不想加命名空间，需要使用：using std::priority_queue;// 不推荐直接使用 using namespace std;std::priority_queue&lt;T, Container, Compare&gt; /* * T: 储存的元素类型 * Container: * 储存的容器类型，且要求满足顺序容器的要求、具有随机访问迭代器的要求 且支持 * front() / push_back() / pop_back() 三个函数， 标准容器中 std::vector / * std::deque 满足这些要求。 Compare: 默认为严格的弱序比较类型 * priority_queue 是按照元素优先级大的在堆顶，根据 operator &lt; * 的定义，默认是大根堆， 我们可以利用 * greater&lt;T&gt;（若支持），或者自定义类的小于号重载实现排序。 * 注意：只支持小于号重载而不支持其他比较符号的重载。 */ // 构造方式 ： std::priority_queue&lt;int&gt;;std::priority_queue&lt;int, vector&lt;int&gt;&gt; // C++11前，请使用 vector&lt;int&gt; &gt;，空格不可省略 std::priority_queue&lt;int, deque&lt;int&gt;, greater&lt;int&gt;&gt; // 注意：不可跳过容器参数直接传入比较类 成员函数 top() : 访问栈顶元素 常数复杂度 empty() : 检查底层的容器是否为空 常数复杂度 size() : 返回底层容器的元素数量 常数复杂度 push() : 插入元素，并对底层容器排序 最坏$\Theta(n)$均摊$\Theta(log(n))$ pop() : 删除第一个元素 最坏$\Theta(log(n))$ 由于 std::priority_queue 原生不支持 modify() / join() / erase() 故不做讲解。 Code123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;int n;int a;priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; pq;int main()&#123; while (cin &gt;&gt; n) &#123; int sum = 0; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a; pq.push(a); &#125; if (n == 1) cout &lt;&lt; a &lt;&lt; endl; else &#123; for (int i = 1; i &lt; n; i++) &#123; int l = pq.top(); pq.pop(); int r = pq.top(); pq.pop(); sum += l + r; pq.push(l + r); &#125; cout &lt;&lt; sum &lt;&lt; endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Greedy</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>洛谷</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[100-Days-Of-ML-Code Day2 简单线性回归模型]]></title>
    <url>%2F2019%2F03%2F06%2F100%E5%A4%A9ML-2%2F</url>
    <content type="text"><![CDATA[简单线性回归模型|第2天Steps Datasets Hours Scores 0 2.5 21 1 5.1 47 2 3.2 27 3 8.5 75 4 3.5 30 5 1.5 20 6 9.2 88 7 5.5 60 8 8.3 81 9 2.7 25 10 7.7 85 11 5.9 62 12 4.5 41 13 3.3 42 14 1.1 17 15 8.9 95 16 2.5 30 17 1.9 24 18 6.4 67 19 7.4 69 20 2.7 30 21 4.8 54 22 3.8 35 23 6.9 76 24 7.8 86 Code第1步：数据预处理12345678910import pandas as pdimport numpy as npimport matplotlib.pyplot as pltdataset = pd.read_csv('studentscores.csv')X = dataset.iloc[:,:1].valuesY = dataset.iloc[:,1].valuesfrom sklearn.model_selection import train_test_splitX_train,X_test,Y_train,Y_test = train_test_split(X,Y,test_size = 1/4,random_state = 0) 第2步：训练集使用简单线性回归模型来训练12345678from sklearn.linear_model import LinearRegressionregressor = LinearRegression()#普通最小二乘线性回归LinearRegression(fit_intercept=True, normalize=False, copy_X=True, n_jobs=None)#fit_intercept是否计算此模型的借距#normalize设置为False 时，将忽略此参数。如果为True，则回归量X将在回归之前通过减去平均值并除以l2范数来归一化#如果为True，则将复制X; 否则，它可能会被覆盖#n_jobs设定工作的core数量regressor = regressor.fit(X_train,Y_train) 第3步：预测结果1Y_pred = regressor.predict(X_test) 第4步：可视化训练集结果可视化123plt.scatter(X_train,Y_train,color = 'red')#根据数组绘制散点图plt.plot(X_train,regressor.predict(X_train),color = 'blue')#绘制坐标图plt.show() 测试集结果可视化123plt.scatter(X_test,Y_test,color = 'red')plt.plot(X_test,Y_pred,color = 'blue')plt.show()]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[100-Days-Of-ML-Code Day1 数据预处理]]></title>
    <url>%2F2019%2F03%2F05%2F100%E5%A4%A9ML-1%2F</url>
    <content type="text"><![CDATA[数据预处理|第1天Steps Datasets Country Age Salary Purchased France 44 72000 No Spain 27 48000 Yes Germany 30 54000 No Spain 38 61000 No Germany 40 Yes France 35 58000 Yes Spain 52000 No France 48 79000 Yes Germany 50 83000 No France 37 67000 Yes Code第1步：导入库12import numpy as npimport pandas as pd 第2步：导入数据集123dataset = pd.read_csv('Data.csv')#读取csv文件X = dataset.iloc[ : , :-1].values#.iloc[行，列]Y = dataset.iloc[ : , 3].values#:全部行or列；[a]第a行or列；[a,b,c]第a,b,c行or列 第3步：处理丢失数据1234567891011121314151617from sklearn.preprocessing import Imputerimputer = Imputer(missing_values = "NaN",strategy = "mean",axis = 0)#填补缺失值sklearn.preprocessing.Imputer(missing_values=’NaN’, strategy=’mean’, axis=0, verbose=0, copy=True)#missing_values：缺失值，可以为整数或NaN(缺失值numpy.nan用字符串‘NaN’表示)，默认为NaN#strategy：替换策略，字符串，默认用均值‘mean’替换#①若为mean时，用特征列的均值替换#②若为median时，用特征列的中位数替换#③若为most_frequent时，用特征列的众数替换#axis：指定轴数，默认axis=0代表列，axis=1代表行#copy：设置为True代表不在原数据集上修改，设置为False时，就地修改，存在如下情况时，即使设置为False时，也不会就地修改#①X不是浮点值数组#②X是稀疏且missing_values=0#③axis=0且X为CRS矩阵#④axis=1且X为CSC矩阵#statistics_属性：axis设置为0时，每个特征的填充值数组，axis=1时，报没有该属性错误imputer = imputer.fit(X[:,1:3])#填补缺失值X[:,1:3] = imputer.transform(X[:,1:3])#替换原数据 第4步：解析分类数据123from sklearn.preprocessing import LabelEncoder,OneHotEncoderlabelencoder_X = LabelEncoder()#LabelEncoder给标签编码为0-n_classes-1之间的值X[:,0] = labelencoder_X.fit_transform(X[:,0])#编码并返回替换原数据 创建虚拟变量1234567891011onehotencoder=OneHotEncoder(categorical_features = [0])#将分类特征的每个元素转化为一个可以用来计算的值OneHotEncoder(n_values=’auto’, categorical_features=’all’, dtype=&lt;class ‘numpy.float64’&gt;, sparse=True, handle_unknown=’error’)#n_values=’auto’,表示每个特征使用几维的数值由数据集自动推断，即几种类别就使用几位来表示#categorical_features = 'all'这个参数指定了对哪些特征进行编码，默认对所有类别都进行编码#dtype=&lt;class ‘numpy.float64’&gt; 表示编码数值格式，默认是浮点型#sparse=True 表示编码的格式，默认为 True，即为稀疏的格式，指定 False 则就不用 toarray() 了#handle_unknown=’error’，其值可以指定为 "error" 或者 "ignore"，即如果碰到未知的类别，是返回一个错误还是忽略它#方法 transform(X) 就是对 X 进行编码了。在实际应用中，我们更常用方法 fit_transform()，也就是一步到位X = onehotencoder.fit_transform(X).toarray()#编码并替换labelencoder_Y = LabelEncoder()Y = labelencoder_Y.fit_transform(Y) 第5步：拆分数据集为训练集合和测试集合1234567from sklearn.model_selection import train_test_splitX_train, X_test,Y_train,Y_test = train_test_split(X,Y,test_size = 0.2,random_state = 0)#将矩阵随机划分为训练子集和测试子集，并返回划分好的训练集测试集样本和训练集测试集标签train_test_split(train_data,train_target,test_size=0.3, random_state=0)#train_data：被划分的样本特征集#train_target：被划分的样本标签#test_size：如果是浮点数，在0-1之间，表示样本占比；如果是整数的话就是样本的数量#random_state：是随机数的种子 第6步：特征量化12345678from sklearn.preprocessing import StandardScalersc_X=StandardScaler()#计算训练集的平均值和标准差，以便测试数据集使用相同的变换StandardScaler(copy=True, with_mean=True, with_std=True)#z = (x - u) / s删除平均值，并缩放到单位方差#u是训练样本的均值，如果with_mean=False,则为0#s是训练样本的标准偏差，如果with_std=False,则为1X_train = sc_X.fit_transform(X_train)X_test=sc_X.transform(X_test)]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1538 迎春舞会之数字舞蹈]]></title>
    <url>%2F2019%2F03%2F04%2F%E6%B4%9B%E8%B0%B7P1538%2F</url>
    <content type="text"><![CDATA[Description在越来越讲究合作的时代，人们注意的更多的不是个人物的舞姿，而是集体的排列。 为了配合每年的倒计时，同学们决定排出——“数字舞蹈”。顾名思义就是所有人一起排成若干个数字，更为创新的是，每个人都是趴在地上，保证横竖。 现在给出数字及其要求摆出的大小，请你编程，模拟同学们的优美姿态。 Input第一行为k。k表示要摆出数字的大小。 第二行为全部由数字组成的字符串，即要摆出的几个数字。 Output按题目要求输出。 Sample Input1221234567890 Sample Output1234567 -- -- -- -- -- -- -- -- | | | | | | | | | | | | | || | | | | | | | | | | | | | -- -- -- -- -- -- -- | | | | | | | | | | | | || | | | | | | | | | | | | -- -- -- -- -- -- -- Analysis每个数字，考虑每根线的占位，从上至下从左至右，最多的由7根线组成。可以用一个字符串数组来保存0-9每个数字的组成方式。 比如数字8就是“-||-||-”，空位用空格占位，那么1就是“ | | ”，以此类推。 打印时分为横线和竖线。可以发现横线刚好是0，3，6位，可以用模3取余来判断是否为横线。 大小k就是循环打印k个空格或k条线。 注意打印的时候不是每次打印一个数字，而是一行一行打印。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;using namespace std;string map[10] = &#123; "-|| ||-"," | | ","- |-| -","- |- |-"," ||- | ","-| - |-","-| -||-","- | | ","-||-||-","-||- |-" &#125;;int main()&#123; string s; int k; cin &gt;&gt; k; cin.get(); cin &gt;&gt; s; for (int n = 0; n &lt; 7; n++) &#123; if (n % 3 == 0) &#123; for (int i = 0; i &lt; s.size(); i++) &#123; cout &lt;&lt; ' '; for (int j = 0; j &lt; k; j++) &#123; cout &lt;&lt; map[s[i] - '0'][n]; &#125; cout &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; else if (n == 1 || n == 4) &#123; for (int m = 0; m &lt; k; m++) &#123; for (int i = 0; i &lt; s.size(); i++) &#123; cout &lt;&lt; map[s[i] - '0'][n]; for (int j = 0; j &lt; k; j++) &#123; cout &lt;&lt; ' '; &#125; cout &lt;&lt; map[s[i] - '0'][n + 1] &lt;&lt; ' '; &#125; cout &lt;&lt; endl; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Others</category>
      </categories>
      <tags>
        <tag>水题</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1309 瑞士轮]]></title>
    <url>%2F2019%2F02%2F16%2F%E6%B4%9B%E8%B0%B7P1309%2F</url>
    <content type="text"><![CDATA[Description$2\times N$名编号为 $1\sim 2N$ 的选手共进行$R$轮比赛。每轮比赛开始前，以及所有比赛结束后，都会按照总分从高到低对选手进行一次排名。选手的总分为第一轮开始前的初始分数加上已参加过的所有比赛的得分和。总分相同的，约定编号较小的选手排名靠前。 每轮比赛的对阵安排与该轮比赛开始前的排名有关：第1名和第2名、第3名和第4名、……、第$2K-1$名和第$2K$名、…… 、第$2N-1$名和第$2N$名，各进行一场比赛。每场比赛胜者得1分，负者得0分。也就是说除了首轮以外，其它轮比赛的安排均不能事先确定，而是要取决于选手在之前比赛中的表现。 现给定每个选手的初始分数及其实力值，试计算在R轮比赛过后，排名第Q的选手编号是多少。我们假设选手的实力值两两不同，且每场比赛中实力值较高的总能获胜。 Input第一行是三个正整数$N,R,Q$每两个数之间用一个空格隔开，表示有$2\times N$名选手、R轮比赛，以及我们关心的名次Q。 第二行是$2\times N$个非负整数$s1,s_2,\dots,s{2N},$每两个数之间用一个空格隔开，其中$si$表示编号为i的选手的初始分数。 第三行是$2\times N$个正整数$w_1,w_2,\dots,w{2N}$每两个数之间用一个空格隔开，其中$w_i$表示编号为i的选手的实力值。 Output一个整数，即R轮比赛结束后，排名第Q的选手的编号。 Sample Input1232 4 2 7 6 6 7 10 5 20 15 Sample Output11 Analysis每组比赛的胜者：赛前，总分是按降序排的；获胜后都得1分，仍是降序； 每组比赛的负者：赛前，总分是按降序排的；不得分，仍是降序。 先按初始分数排序，然后按分数高低两人一组比赛； 胜者入队A，负者入队B。这样A、B自身仍是有序的； 只需进行合并操作即可，合并操作的复杂度是O(n),而如果用快排其复杂度为O(nlogn) Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int N, R, Q;int W[200005];struct node&#123; int s; int id;&#125;;node a[200005];node A[100005];node B[100005];bool cmp(node x, node y)&#123; if (x.s != y.s) return x.s &gt; y.s; else return x.id &lt; y.id;&#125;void merge()&#123; int i = 1, j = 1, k = 1; while (i &lt;= N &amp;&amp; j &lt;= N) &#123; if ((A[i].s &gt; B[j].s) || (A[i].s == B[j].s&amp;&amp;A[i].id &lt; B[j].id)) &#123; a[k].s = A[i].s; a[k++].id = A[i++].id; &#125; else &#123; a[k].s = B[j].s; a[k++].id = B[j++].id; &#125; &#125; while (i &lt;= N) &#123; a[k].s = A[i].s; a[k++].id = A[i++].id; &#125; while (j &lt;= N) &#123; a[k].s = B[j].s; a[k++].id = B[j++].id; &#125;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; R &gt;&gt; Q; for (int i = 1; i &lt;= 2 * N; i++) &#123; cin &gt;&gt; a[i].s; a[i].id = i; &#125; for (int i = 1; i &lt;= 2 * N; i++) &#123; cin &gt;&gt; W[i]; &#125; sort(a + 1, a + 1 + 2 * N, cmp); for (int i = 1; i &lt;= R; i++) &#123; int tt = 1; for (int j = 1; j &lt; 2 * N; j += 2) &#123; if (W[a[j].id] &gt; W[a[j+1].id]) &#123; A[tt].s = a[j].s + 1; A[tt].id = a[j].id; B[tt].s = a[j + 1].s; B[tt].id = a[j + 1].id; tt++; &#125; else &#123; A[tt].s = a[j + 1].s + 1; A[tt].id = a[j + 1].id; B[tt].s = a[j].s; B[tt].id = a[j].id; tt++; &#125; &#125; merge(); &#125; cout &lt;&lt; a[Q].id &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Sort</category>
        <category>Merge Sort</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第6章 线性空间与线性变换]]></title>
    <url>%2F2019%2F02%2F16%2F%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B06%2F</url>
    <content type="text"><![CDATA[§1 线性空间的定义与性质定义1 设$V$是一个非空集合，$\mathbb{R}$为实数域。如果在$V$中定义了一个加法，即对于任意两个元素$\alpha,\beta\in V$，总有惟一的一个元素$\gamma\in V$与之对应，称为$\alpha$与$\beta$的和，记作$\gamma=\alpha+\beta$；在$V$中又定义了一个数的乘法(简称数乘)，即对于任一数$\lambda\in\mathbb{R}$与任意元素$\alpha\in V$，总有惟一的一个元素$\delta\in V$与之对应，称为$\lambda$与$\alpha$的数量乘积，记作$\delta=\lambda\alpha$，并且这两种运算满足以下八条运算规律(设$\alpha、\beta、\gamma\in V,\lambda、\mu\in\mathbb{R}$)： (i)$\alpha+\beta=\beta+\alpha$； (ii)$(\alpha+\beta)+\gamma=\alpha+(\beta+\gamma)$； (iii)在$V$中存在零元素0，对任何$\alpha\in V$，都有$\alpha+0=\alpha$； (iv)对任何$\alpha\in V$，都有$\alpha$的负元素$\beta\in V$，使$\alpha+\beta-0$； (v)$1\alpha=\alpha$； (vi)$\lambda(\mu\alpha)=(\lambda\mu)\alpha$； (vii)$(\lambda+\mu)\alpha=\lambda\alpha+\mu\alpha$； (viii)$\lambda(\alpha+\beta)=\lambda\alpha+\lambda\beta$； 那么就称$V$为(实数域$\mathbb{R}$上的)向量空间(或线性空间)，$V$中的元素不论其本来的性质如何，统称为(实)向量。 线性空间的性质： 1.零向量是惟一的. 2.任一向量的负向量是惟一的，$\alpha$的负向量记作$-\alpha$. 3.$0\alpha=0,(-1)\alpha=-\alpha,\lambda0=0.$ 4.如果$\lambda\alpha=0$，则$\lambda=0$或$\alpha=0$. 定义2 设$V$是一个线性空间，$L$是$V$的一个非空子集，如果$L$对于$V$中所定义的加法和数乘两种运算也构成一个线性空间，则称$L$为$V$的子空间。 定理1 线性空间$V$的非空子集$L$构成子空间的充分必要条件是：$L$对于$V$中的线性运算封闭。 §2 维数、基与坐标定义3 在线性空间$V​$中，如果存在n个向量$\alpha_1,\alpha_2,\dots,\alpha_n​$，满足： (i)$\alpha_1,\alpha_2,\dots,\alpha_n$线性无关； (ii)$V​$中任一向量$\alpha​$总可由$\alpha_1,\alpha_2,\dots,\alpha_n​$线性表示， 那么$\alpha_1,\alpha_2,\dots,\alpha_n​$就称为线性空间$V​$的一个基，n称为线性空间$V​$的维数。只含一个零向量的线性空间没有基，规定它的维数为0。维数为n的线性空间称为n维线性空间，记作$V_n​$。 定义4 设$\alpha_1,\alpha_2,\dots,\alpha_n​$是线性空间$V_n​$的一个基，对于任一向量$\alpha\in V_n​$，总有且仅有一组有序数$x_1,x_2,\dots,x_n​$使$\alpha=x_1\alpha_1+x_2\alpha_2+\dots+x_n\alpha_n,x_1,x_2,\dots,x_n​$这组有序数就称为向量$\alpha​$在$\alpha_1,\alpha_2,\dots,\alpha_n​$这个基中的坐标，并记作$\alpha=(x_1,x_2,\dots,x_n)^T​$。 设$V$与$U$是两个线性空间，如果在它们的向量之间有一一对应关系，且这个对应关系保持线性组合的对应，那么就说线性空间$V$与$U$同构。维数相等的线性空间都同构。 §3 基变换与坐标变换定理2 设$V_n​$中的向量$\alpha​$在基$\alpha_1,\alpha_2,\dots,\alpha_n​$中的坐标为$(x_1,x_2,\dots,x_n)^T​$，在基$\beta_1,\beta_2,\dots,\beta_n​$中的坐标为$\alpha=(x_1’,x_2’,\dots,x_n’)^T​$。若两个基满足关系式$(\beta_1,\beta_2,\dots,\beta_n)=(\alpha_1,\alpha_2,\dots,\alpha_n)P​$，则有坐标变换公式 \left( \begin{matrix} x_1\\ x_2\\ \vdots\\ x_n \end{matrix} \right)=P \left( \begin{matrix} x_1'\\ x_2'\\ \vdots\\ x_n' \end{matrix} \right)或 \left( \begin{matrix} x_1'\\ x_2'\\ \vdots\\ x_n' \end{matrix} \right)=P^{-1} \left( \begin{matrix} x_1\\ x_2\\ \vdots\\ x_n \end{matrix} \right)§4 线性变换定义5 设有两个非空集合$A,B,$如果对于$A$中任一元素$\alpha,$按照一定的规则，总有$B$中一个确定的元素$\beta$和它对应，那么，这个对应规则称为从集合$A$到集合$B$的映射。常用字母表示一个映射，譬如把上述映射记作$T$，并记 \beta=T(\alpha)或\beta=T\alpha(\alpha\in A)定义6 设$V_n,U_m$分别是n维和m维线性空间，$T$是一个从$V_n$到$U_m$的映像，如果映射$T$满足： (i)任给$\alpha_1、\alpha_2\in V_n$(从而$\alpha_1+\alpha_2\in V_n$),有$T(\alpha_1+\alpha_2)=T(\alpha_1)+T(\alpha_2)$； (ii)任给$\alpha\in V_n$，$\lambda\in\mathbb{R}$(从而$\lambda\alpha\in V_n$)，有$T(\lambda\alpha)=\lambda T(\alpha)$， 那么就称$T$为从$V_n$到$U_m$的线性映射，或线性变换。 线性变换具有下述基本性质： (i)$T0=0,T(-\alpha)=-T\alpha$。 (ii)若$\beta=k_1\alpha_1+k_2\alpha_2+\dots+k_m\alpha_m,$则$T\beta=k_1T\alpha_1+k_2T\alpha_2+\dots+k_mT\alpha_m$。 (iii)若$\alpha_1,\alpha_2,\dots,\alpha_m$线性相关，则$T\alpha_1,T\alpha_2,\dots,T\alpha_m$亦线性相关。 (iv)线性变换$T$的像集$T(V_n)$是一个线性空间，称为线性变换$T$的像空间。 (v)使$T\alpha=0$的$\alpha$的全体$N_T={\alpha|\alpha\in V_n,T\alpha=0}$也是一个线性空间。$N_T$称为线性变换$T$的核。 §5 线性变换的矩阵表示式定义7 设$T$是线性空间$V_n$中的线性变换，在$V_n$中取定一个基$\alpha_1,\alpha_2,\dots,\alpha_n,$如果这个基在变换$T$下的像(用这个基线性表示)为 \left\{ \begin{aligned} &T(\alpha_1)=a_{11}\alpha_1+a_{21}\alpha_2+\dots+a_{n1}\alpha_n,\\ &T(\alpha_2)=a_{12}\alpha_1+a_{22}\alpha_2+\dots+a_{n2}\alpha_n,\\ &\dots\dots\dots\dots\\ &T(\alpha_n)=a_{1n}\alpha_1+a_{2n}\alpha_2+\dots+a_{nn}\alpha_n,\\ \end{aligned} \right.记$T(\alpha_1,\alpha_2,\dots,\alpha_n)=(T(\alpha_1)，T(\alpha_2),\dots,T(\alpha_n)),​$上式表示为$T(\alpha_1,\alpha_2,\dots,\alpha_n)=(\alpha_1,\alpha_2,\dots,\alpha_n)A,​$其中 A= \left( \begin{matrix} a_{11}&a_{12}&\dots&a_{1n}\\ a_{21}&a_{22}&\dots&a_{2n}\\ \vdots&\vdots&&\vdots\\ a_{n1}&a_{n2}&\dots&a_{nn} \end{matrix} \right)那么$A$就称为线性变换$T$在基$\alpha_1,\alpha_2,\dots,\alpha_n$下的矩阵。 定理3 设线性空间$V_n$中取定两个基 \alpha_1,\alpha_2,\dots,\alpha_n;\beta_1,\beta_2,\dots,\beta_n,由基$\alpha_1,\alpha_2,\dots,\alpha_n$到基$\beta_1,\beta_2,\dots,\beta_n$的过渡矩阵为$P，V_n$中的线性变换$T$在这两个基下的矩阵依次为$A$和$B$，那么$B=P^{-1}AP$。 定义8 线性变换$T$的像空间$T(V_n)$的维数，称为线性变换$T$的秩。 显然，若$A$是$T$的矩阵，则$T$的秩就是$R(A)$。 若$T$的秩为r，则$T$的核$N_T$的维数为n-r。]]></content>
      <categories>
        <category>Basics</category>
        <category>Linear Algebra</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第5章 相似矩阵及二次型]]></title>
    <url>%2F2019%2F02%2F15%2F%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B05%2F</url>
    <content type="text"><![CDATA[§1 向量的内积、长度及正交性定义1 设有n维向量 x= \left( \begin{matrix} x_1\\ x_2\\ \vdots\\ x_n \end{matrix} \right), y= \left( \begin{matrix} y_1\\ y_2\\ \vdots\\ y_n \end{matrix} \right)令$[x,y]=x_1y_1+x_2y_2+\dots+x_ny_n$，称为向量$x$与$y$的内积。 内积具有下列性质： (i)$[x,y]=[y,x]$； (ii)$[\lambda x,y]=\lambda[x,y]$； (iii)$[x+y,z]=[x,z]+[y,z]$； (iv)当$x=0$时，$[x,x]=0$；当$x\neq0$时，$[x,x]&gt;0$。 施瓦茨(Schwarz)不等式$[x,y]^2\leq[x,x][y,y]$。 定义2 令$||x||=\sqrt{[x,x]}=\sqrt{x_1^2+x_2^2+\dots+x_n^2},||x||$称为n维向量$x$的长度(或范数)。 向量的长度具有下述性质： (i)非负性 当$x\neq0$时，$||x||&gt;0$；当$x=0$时，$||x||=0$； (ii)齐次性 $||\lambda x||=|\lambda|||x||$； 当$x\neq0、y\neq0$时，$\theta=arccos\frac{[x,y]}{||x||||y||}$称为n维向量$x$与$y$的夹角。当$[x,y]=0$时，称向量$x$与$y$正交。 定理1 若n维向量$a_1,a_2,\dots,a_r$是一组两两正交的非零向量，则$a_1,a_2,\dots,a_r$线性无关。 定义3 设n维向量$e_1,e_2,\dots,e_r$是向量空间$V(V\subseteq\mathbb{R^n})$的一个基，如果$e_1,e_2,\dots,e_r$两两正交，且都是单位向量，则称$e_1,e_2,\dots,e_r$是$V$的一个标准正交基。 设$e_1,e_2,\dots,e_r$是标准正交集，则任意向量$a$都能由$e_1,e_2,\dots,e_r$线性表示，设为$a=\lambda_1e_1+\lambda_2e_2+\dots+\lambda_re_r,$为求其中系数，可用$e_i^T$左乘上式，有$e_i^Ta=\lambda_ie_i^Te_i=\lambda_i,$即$\lambda_i=e_i^Ta=[a,e_i],$这就是向量在标准正交基中的坐标计算公式。 可以用施密特(Schmidt)正交化方法把一个基标准正交化，取： \begin{aligned} &b_1=a_1,\\ &b_2=a_2-\frac{[b_1,a_2]}{[b_1,b_1]}b_1,\\ &\dots\dots\dots\dots\\ &b_r=a_r-\frac{[b_1,a_r]}{[b_1,b_1]}b_1-\dots-\frac{[b_{r-1},a_r]}{[b_{r-1},b_{r-1}]}b_{r-1}, \end{aligned}然后把它们单位化，即： e_1=\frac{1}{||b_1||}b_1,e_2=\frac{1}{||b_2||}b_2,\dots,e_r=\frac{1}{||b_r||}b_r就是$V$的一个标准正交基。 定义4 如果n阶矩阵$A$满足$A^TA=E(即A^{-1}=A^T),$那么称$A​$为正交矩阵，简称正交阵。 方阵为正交矩阵的充分必要条件是列向量都是单位向量，且两两正交。 因为$A^TA=E与AA^T=E$等价，所以上述结论对行向量亦成立。 正交矩阵具有以下性质： (i)若$A$为正交矩阵，则$A^{-1}=A^T$也是正交矩阵，且$|A|=1或(-1)$； (ii)若$A$和$B$都是正交矩阵，则$AB$也是正交矩阵。 定义5 若$P$为正交矩阵，则线性变换$y=Px$称为正交变换。 设$y=Px$为正交变换，则有$||y||=\sqrt{y^Ty}=\sqrt{x^TP^TPx}=sqrt{x^Tx}=||x||$。 说明经正交变换线段长度不变。 §2 方阵的特征值与特征向量定义6 设$A$是n阶矩阵，如果数$\lambda$和n维非零列向量$x$使关系式 Ax=\lambda x (1)成立，那么，这样的数$\lambda$称为矩阵$A$的特征值，非零向量$x$称为$A$的对应于特征值$\lambda$的特征向量。(1)式也可写成$(A-\lambda E)x=0$。它有非零解的充分必要条件是系数行列式$|A-\lambda E|=0$，称为矩阵$A$的特征方程，方程左端称为矩阵$A$的特征多项式。n阶矩阵在复数范围内有n个特征值。 设n阶矩阵$A=(a_{ij})​$的特征值为$\lambda_1,\lambda_2,\dots,\lambda_n,​$不难证明 (i)$\lambda1+\lambda_2+\dots+\lambda_n=a{11}+a{22}+\dots+a{nn}$； (ii)$\lambda_1\lambda_2\dots\lambda_n=|A|$。 可知$A$是可逆矩阵的充要条件是n个特征值全不为零。 定理2 设$\lambda_1,\lambda_2,\dots,\lambda_m$是方阵$A$的m个特征值，$p_1,p_2,\dots,p_m$依次是与之对应的特征向量，如果$\lambda_1,\lambda_2,\dots,\lambda_m$各不相等，则$p_1,p_2,\dots,p_m$线性无关。 推论 设$\lambda_1$和$\lambda_2$是方阵的两个不同特征值，$\xi_1,\xi_2,\dots,\xi_s$和$\eta_1,\eta_2,\dots,\eta_t$分别是对应于$\lambda_1$和$\lambda_2$的线性无关的特征向量，则$\xi_1,\xi_2,\dots,\xi_s,\eta_1,\eta_2,\dots,\eta_t$线性无关。 §3 相似矩阵定义7 设$A、B$都是n阶矩阵，若有可逆矩阵$P$使$P^{-1}AP=B$，则称$B$是$A$的相似矩阵，或说矩阵$A$与$B$相似。对$A$进行运算$P^{-1}AP$称为对$A$进行相似变换，可逆矩阵$P$称为把$A$变成$B$的相似变换矩阵。 定理3 若n阶矩阵$A$与$B$相似，则$A$与$B$的特征多项式相同，从而$A$与$B$特征值亦相同。 推论 若n阶矩阵$A$与对角矩阵 \Lambda= \left( \begin{matrix} \lambda_1&&&\\ &\lambda_2&&\\ &&\ddots&\\ &&&\lambda_n \end{matrix} \right)相似，则$\lambda_1,\lambda_2,\dots,\lambda_n​$即是$A​$的n个特征值 定理4 n阶矩阵$A$与对角矩阵相似(即$A$能对角化)的充分必要条件是$A$有n个线性无关的特征向量。 推论 如果n阶矩阵$A$的n个特征值互不相等，则$A$与对角矩阵相似。 §4 对称矩阵的对角化性质1 对称矩阵的特征值为实数。 性质2 设$\lambda_1,\lambda_2$是对称矩阵$A$的两个特征值，$p_1,p_2$是对应的特征向量。若$\lambda_1\neq\lambda_2$，则$p_1$与$p_2$正交。 定理5 设$A$为n阶对称矩阵，则必有正交矩阵$P$，使$P^{-1}AP=P^TAP=\Lambda$，其中$\Lambda$是以$A$的n个特征值为对角元的对角矩阵。 推论 设$A$为n阶对称矩阵，$\lambda$是$A$的特征方程的k重根，则矩阵$A-\lambda E$的秩$R(A-\lambda E)=n-k$，从而对应特征值$\lambda$恰有k个线性无关的特征向量。 把对称矩阵$A$对角化的步骤： (i)求出$A$的全部互不相等的特征值$\lambda_1,\lambda_2,\dots,\lambda_s,$他们的重数依次为$k_1,\dots,k_s(k_1+\dots+k_s=n)$。 (ii)对每个$k_i$重特征值$\lambda_i,$求方程$(A-\lambda_iE)x=0$的基础解系，得$k_i$个线性无关的特征向量。再把它们正交化、单位化，得$k_i$个两两正交的单位特征向量。因$k_1+\dots+k_s=n$，故总共可得n个两两正交的单位特征向量。 (iii)把这n个两两正交的单位特征向量构成正交矩阵$P$，便有便有$P^{-1}AP=P^TAP=\Lambda$。注意$\Lambda$中对角元的排列次序应与$P$中列向量的排列次序相对应。 §5 二次型及其标准形定义8 含有n个变量$x_1,x_2,\dots,x_n​$的二次齐次函数 \begin{aligned} f(x_1,x_2,\dots,x_n)=&a_{11}x_1^2+a_{22}x_2^2+\dots+a_{nn}x_n^2+\\ &2a_{12}x_1x_2+2a_{13}x_1x_3+\dots+2a_{n-1,n}x_{n-1}x_n (5) \end{aligned}称为二次型。当$j&gt;i$时，取$a{ji}=a{ij}$，则$2a{ij}x_ix_j=a{ij}xix_j+a{ji}x_jx_i$，于是(5)可写成 \begin{aligned} f=&a_{11}x_1^2+a_{12}x_1x_2+\dots+a_{1n}x_1x_n+a_{21}x_2x_1+a_{22}x_2^2+\dots+a_{2n}x_2x_n+\dots+\\ &a_{n1}x_nx_1+a_{n2}x_nx_2+\dots+a_{nn}x_n^2=\sum_{i,j=1}^na_{ij}x_ix_j (6) \end{aligned}只含平方项的二次型称为二次型的标准形(或法式)。 如果标准形的系数只在1，-1，0三个数中取值，称为二次型的规范形。 二次型可用矩阵记作 f=x^TAx (8)其中$A$为对称矩阵。 定义9 设$A$和$B$是n阶矩阵，若有可逆矩阵$C$，使$B=C^TAC$，则称矩阵$A$与$B$合同。 对于对称矩阵$A$，寻求可逆矩阵$C$，使$C^TAC$为对角矩阵。这个问题称为把对称矩阵$A$合同对角化。 定理6 任给二次型$f=\sum{i,j=1}^na{ij}xix_j(a{ij}=a_{ji})$，总有正交变换$x=Py$，使$f$化为标准形 f=\lambda_1y_1^2+\lambda_2y_2^2+\dots+\lambda_ny_n^2其中$\lambda1,\lambda_2,\dots,\lambda_n$是$f$的矩阵$A=(a{ij})$的特征值。 推论 任给n元二次型$f(x)=x^TAx(A^T=A)$，总有可逆变换$x=Cz$，使$f(Cz)$为规范形。 §6 用配方法化二次型成标准形拉格朗日配方法。 例15 化二次型$f=x_1^2+2x_2^2+5x_3^2+2x_1x_2+2x_1x_3+6x_2x_3$为标准形并求所用的变换矩阵。 配方为$f=(x_1+x_2+x_3)^2+(x_2+2x_3)^2$ 令$y_1=x_1+x_2+x_3,y_2=x_2+2x_3,y_3=x_3$,就化为标准形$f=y_1^2+y_2^2$。所用变换矩阵为 C= \left( \begin{matrix} 1&-1&1\\ 0&1&-2\\ 0&0&1 \end{matrix} \right)§7 正定二次型定理7 设二次型$f=x^TAx$的秩为r，且有两个可逆变换 x=Cy及x=Pz\\ f=k_1y_1^2+k_2y_2^2+\dots+k_ry_r^2(k_i\neq0)及f=\lambda_1z_1^2+\lambda_2z_2^2+\dots+\lambda_rz_r^2(\lambda_i\neq0)则$k_1,\dots,k_r$中正数的个数与$\lambda_1,\dots,\lambda_r$中正数的个数相等。称为惯性定理。 二次型的标准形中正系数的个数称为二次型的正惯性指数，负系数的个数称为负惯性指数。 定义10 设二次型$f(x)=x^TAx$，如果对任何$x\neq0$，都有$f(x)&gt;0$，则称f为正定二次型，并称对称矩阵$A$是正定的；如果对任何$x\neq0$都有$f(x)&lt;0$，则称f为负定二次型，并称对称矩阵$A$是负定的。 定理8 n元二次型$f=x^TAx$为正定的充分必要条件是：它的标准形的n个系数全为正，即它的规范形的n个系数全为1，亦即它的正惯性指数等于n。 推论 对称矩阵$A$为正定的充分必要条件是：$A$的特征值全为正。 定理9 对称矩阵$A$为正定的充分必要条件是：$A$的各阶主子式都为正，即 a_{11}>0, \left| \begin{matrix} a_{11}&a_{12}\\ a_{21}&a_{22} \end{matrix} \right|>0,\dots, \left| \begin{matrix} a_{11}&\dots&a_{1n}\\ \vdots&&\vdots\\ a_{n1}&\dots&a_{nn} \end{matrix} \right|>0对称矩阵$A$为负定的充分必要条件是：奇数阶主子式为负，而偶数阶主子式为正，即 (-1)^r \left| \begin{matrix} a_{11}&\dots&a_{1r}\\ \vdots&&\vdots\\ a_{r1}&\dots&a_{rr} \end{matrix} \right|>0(r=1,2,\dots,n)这个定理称为赫尔维茨定理。]]></content>
      <categories>
        <category>Basics</category>
        <category>Linear Algebra</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第4章 向量组的线性相关性]]></title>
    <url>%2F2019%2F02%2F14%2F%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B04%2F</url>
    <content type="text"><![CDATA[§1 向量组及其线性组合定义1 n个有次序的数$a_1,a_2,\dots,a_n$所组成的数组称为n维向量，这n个数称为该向量的n个分量，第i个数$a_i$称为第i个分量。 定义2 给定向量组$A:a_1,a_2,\dots,a_m,$对于任何一组实数$k_1,k_2,\dots,k_m,$表达式 k_1a_1+k_2a_2+\dots+k_ma_m称为向量组$A$的一个线性组合，$k_1,k_2,\dots,k_m$称为这个线性组合的系数。 给定向量组$A:a_1,a_2,\dots,a_m​$和向量$b​$，如果存在一组数$\lambda_1,\lambda_2,\dots,\lambda_m,​$使 b=\lambda_1a_1+\lambda_2a_2+\dots+\lambda_ma_m则向量$b$是向量组$A$的线性组合，称向量$b$能由向量组$A$线性表示。 定理1 向量$b​$能由向量组$A:a_1,a_2,\dots,a_m​$线性表示的充分必要条件是矩阵$A=(a_1,a_2,\dots,a_m)​$的秩等于矩阵$B=(a_1,a_2\dots,a_m,b)​$的秩。 定义3 设有两个向量组$A:a_1,a_2,\dots,a_m​$及$B:b_1,b_2,\dots,b_l,​$若$B​$组中的每个向量都能由向量组$A​$线性表示，则称向量组$B​$能由向量组$A​$线性表示。若向量组$A​$与向量组$B​$都互相线性表示，则称这两个向量组等价。 定理2 向量组$B:b_1,b_2,\dots,b_l​$能由向量组$A:a_1,a_2,\dots,a_m​$线性表示的充分必要条件是矩阵$A=(a_1,a_2,\dots,a_m)​$的秩等于矩阵$(A,B)=(a_1,\dots,a_m,b_1,\dots,b_l)​$的秩，即$R(A)=R(A,B)​$。 推论 向量组$A:a_1,a_2,\dots,a_m​$与向量组$B:b_1,b_2,\dots,b_l​$等价的充分必要条件是 R(A)=R(B)=R(A,B)其中$A$和$B$是向量组$A$和$B$所构成的矩阵。 定理3 设向量组$B:b_1,b_2,\dots,b_l​$能由向量组$A:a_1,a_2,\dots,a_m​$线性表示，则$R(b_1,b_2,\dots,b_l)\leq R(a_1,a_2,\dots,a_m)​$。 §2 向量组的线性相关性定义4 给定向量组$A:a_1,a_2,\dots,a_m,$如果存在不全为零的数$k_1,k_2,\dots,k_m,$使 k_1a_1+k_2a_2+\dots+k_ma_m=0则称向量组$A$是线性相关的，否则称它线性无关。 定理4 向量组$A:a_1,a_2,\dots,a_m​$线性相关的充分必要条件是它所构成的矩阵$A=(a_1,a_2,\dots,a_m)​$的秩小于向量个数m；向量组$A​$线性无关的充分必要条件是$R(A)=m​$。 定理5 (1)若向量组$A:a1,a_2,\dots,a_m​$线性相关，则向量组$B:a_1,a_2,\dots,a_m,a{m+1}​$也线性相关。反之，若向量组$B​$线性无关，则向量组$A​$也线性无关。 (2)m个n维向量组成的向量组，当维数n小于向量个数m时一定线性相关。特别地n+1个n维向量一定线性相关。 (3)设向量组$A:a_1,a_2,\dots,a_m$线性无关，而向量组$B:a_1,a_2,\dots,a_m,b$线性相关，则向量$b$必能由向量组$A$线性表示，且表示式是惟一的。 §3 向量组的秩定义5 设有向量组$A$，如果在$A$中能选出r个向量$a_1,a_2,\dots,a_r,$满足 (i)向量组$A_0:a_1,a_2,\dots,a_r$线性无关； (ii)向量组$A$中任意r+1个向量都线性相关，那么称向量组$A_0$是向量组A的一个最大线性无关向量组，最大无关组所含向量个数r称为向量组$A$的秩，记作$R_A$。 只含零向量的向量组没有最大无关组，规定它的秩为0。 推论(最大无关组的等价定义) 设向量组$A_0:a_1,a_2,\dots,a_r$是向量组$A$的一个部分组，且满足 (i)向量组$A_0$线性无关； (ii)向量组$A$的任何一向量都能由向量组$A_0$表示； 那么向量组$A_0$便是向量组$A$的一个最大无关组。 定理6 矩阵的秩等于它的列向量组的秩，也等于它的行向量组的秩。 定理2’ 向量组$b_1,b_2,\dots,b_l​$能由向量组$a_1,a_2,\dots,a_m​$线性表示的充分必要条件是 R(a_1,a_2,\dots,a_m)=R(b_1,b_2,\dots,b_l)定理3’ 若向量组$B$能由向量组$A$线性表示，则$R_B\leq R_A$。 §4 线性方程组的解的结构设有向量方程$Ax=0$。 性质1 若$x=\xi_1,x=\xi_2$为向量方程的解，则$x=\xi_1+\xi_2$也是向量方程的解。 性质2 若$x=\xi_1$为向量方程的解，k为实数，则$x=k\xi_1$也是向量方程的解。 齐次线性方程组的解集的最大无关组称为该齐次线性方程组的基础解系。 定理7 设$m\times n$矩阵$A$的秩$R(A)=r,$则n元齐次线性方程组$Ax=0$的解集$S$的秩$R_s=n-r$。 设有向量方程$Ax=b$。 性质3 设$x=\eta_1$及$x=\eta_2$都是向量方程的解，则$x=\eta_1-\eta_2$为对应的齐次线性方程组$Ax=0$的解。 性质4 设$x=\eta$是非齐次方程的解，$x=\xi$是齐次方程的解，则$x=\eta+\xi$仍是非齐次方程的解。 非齐次方程的通解=对应的齐次方程的通解+非齐次方程的一个特解。 §5 向量空间定义6 设$V$为n维向量的集合，如果集合$V$非空，且集合$V$对于向量的加法及数乘两种运算都封闭，那么就称集合$V$为向量空间。 定义7 设有向量空间$V_1$及$V_2$若$V_1\subseteq V_2$，就称$V_1$是$V_2$的子空间。 定义8 设$V$为向量空间，如果r个向量$a_1,a_2,\dots,a_r\in V$，且满足 (i)$a_1,a_2,\dots,a_r​$线性无关； (ii)$V$中任一向量都可由$a_1,a_2,\dots,a_r$线性表示； 那么，向量组$a_1,a_2,\dots,a_r$就称为向量空间$V$的一个基，r称为向量空间$V$的维数，并称$V$为r维向量空间。 定义9 如果在向量空间$V$中取定一个基$a_1,a_2,\dots,a_r,$那么$V$中任一向量$x$可惟一地表示为 x=\lambda_1a_1+\lambda_2a_2+\dots+\lambda_ra_r数组$\lambda_1,\lambda_2,\dots,\lambda_r$称为向量$x$在基$a_1,a_2,\dots,a_r$中的坐标。 系数矩阵$P=A^{-1}B$称为从旧基到新基的过渡矩阵。$z=P^{-1}y$是从旧坐标到新坐标的坐标变换公式。]]></content>
      <categories>
        <category>Basics</category>
        <category>Linear Algebra</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[背包模板]]></title>
    <url>%2F2019%2F02%2F13%2F%E8%83%8C%E5%8C%85%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int dp[100009], c[100009], w[100009], m[100009];int n, M, t;void zeropack(int cost, int weight)&#123; for (int i = M; i &gt;= cost; i--) dp[i] = max(dp[i - cost] + weight, dp[i]);&#125;void completepack(int cost, int weight)&#123; for (int i = cost; i &lt;= M; i++) dp[i] = max(dp[i - cost] + weight, dp[i]);&#125;void multipack(int cost, int weight, int num)&#123; if (num*cost &gt;= M) &#123; completepack(cost, weight); return; &#125; int k = 1; while (k &lt; num) &#123; zeropack(k*cost, k*weight); num -= k; k *= 2; &#125; zeropack(cost*num, weight*num);&#125;int main()&#123; while (~scanf("%d%d", &amp;M, &amp;n)) &#123; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d%d", &amp;m[i], &amp;c[i]); w[i] = c[i]; &#125; memset(dp, 0, sizeof(dp)); for (int i = 1; i &lt;= n; i++) &#123; multipack(c[i], w[i], m[i]); &#125; printf("%d\n", dp[M]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Dynamic Programming</category>
        <category>Knapsack Problem</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第3章 矩阵的初等变换与线性方程组]]></title>
    <url>%2F2019%2F02%2F13%2F%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B03%2F</url>
    <content type="text"><![CDATA[§1 矩阵的初等变换定义1 下面三种变换称为矩阵的初等行变换： (i)对换两行(对换i,j两行，记作$r_i\leftrightarrow r_j$)； (ii)以数$k\neq0​$乘某一行中的所有元(第i行乘k，记作$r_i\times k​$)； (iii)把某一行所有元的k倍加到另一行对应的元上去(第j行的k倍加到第i行上，记作$r_i+kr_j$)。 把行换成列，即得初等列变换的定义。统称初等变换。 如果$A$经有限次初等变换变成$B$，就称$A$与$B$等价，记作$A\sim B$。矩阵之间的等价关系具有下列性质： (i)反身性 $A\sim A$； (ii)对称性 若$A\sim B$，则$B\sim A$； (iii)传递性 若$A\sim B$，$B\sim C$，则$A\sim C$。 定义2 (1)非零矩阵若满足(i)非零行在零行的上面；(ii)非零行的首非零元所在列在上一行的首非零元所在列的右面，则称此矩阵为行阶梯形矩阵； (2)进一步，若$A$是行阶梯形矩阵，并且还满足：(i)非零行的首非零元素为1；(ii)首非零元所在的列的其他元均为0，则称$A$为行最简形矩阵。 对于任何非零矩阵$A_{m\times n}$，总可经有限次初等行变换把它变为行阶梯形矩阵和行最简形矩阵。 对最简形矩阵再施以初等列变换，可化为标准形。对于$m\times n$矩阵$A$，总可经过初等变换把它化为标准形 F= \left( \begin{matrix} E_r&O\\ O&O \end{matrix} \right)_{m\times n}定理1 设$A$与$B$为$m\times n$矩阵，那么 (i)$A$与$B$行等价的充分必要条件是存在m阶可逆矩阵$P$，使$PA=B$； (ii)$A​$与$B​$列等价的充分必要条件是存在n阶可逆矩阵$Q​$，使$AQ=B​$； (iii)$A$与$B$等价的充分必要条件是存在m阶可逆矩阵$P$及n阶可逆矩阵$Q$，使$PAQ=B$。 定义3 由单位矩阵$E$经过一次初等变换得到的矩阵称为初等矩阵。 性质1 设$A$是一个$m\times n$矩阵，对$A$施行一次初等行变换，相当于在$A$的左边乘相应的m阶初等矩阵；对$A$施行一次初等列变换，相当于在$A$的右边乘相应的n阶初等矩阵 性质2 方阵$A$可逆的充分必要条件是存在有限个初等矩阵$P_1,P_2,\dots,P_l,$使$A=P_1P_2\dots P_l$。 推论 方阵$A$可逆的充分必要条件是$A$和$E$行等价 有可逆矩阵$P$，使$PA=B$，求可逆矩阵$P$： 由于 PA=B\Leftrightarrow \left\{ \begin{array}{rcl} PA=B\\ PE=P \end{array} \right. \Leftrightarrow P(A,E)=(B,P)即$(A,E)$与$(B,P)$行等价，因此如果对矩阵$(A,E)$作初等行变换，当把$A$变为$B$时，$E$就变为$P$。 §2 矩阵的秩定义4 在$m\times n$矩阵$A$中，任取k行k列，位于这些行列交叉处的$k^2$个元素，不改变它们在$A$中所处的位置次序而得的k阶行列式，称为矩阵$A$的k阶子式。 引理 设$A$与$B$行等价，则$A$与$B$中非零子式的最高阶数相等。 定义5 设在矩阵$A$中有一个不等于0的r阶子式$D$，且所有r+1阶子式全等于0，那么$D$称为矩阵$A$的最高阶非零子式，数r称为矩阵$A$的秩，记作$R(A)$。并规定零矩阵的秩等于0。 对于n阶矩阵$A$，由于$A$的n阶子式只有一个$|A|$，故当$|A|\neq0$时，$R(A)=n$，当$|A|=0$时$R(A)&lt;n$。可见可逆矩阵的秩等于矩阵的阶数，不可逆矩阵的秩小于矩阵的阶数。因此可逆矩阵又称满秩矩阵，不可逆矩阵(奇异矩阵)又称降秩矩阵。 定理2 若$A\sim B$，则$R(A)=R(B)$。 推论 若可逆矩阵$P、Q$使$PAQ=B$，则$R(A)=R(B)$。 矩阵的秩的性质归纳： \begin{aligned} &①0\leq R(A_{m\times n})\leq\min\{m,n\}.\\ &②R(A^T)=R(A).\\ &③若A\sim B,则R(A)=R(B).\\ &④若P、Q可逆，则R(PAQ)=R(A).\\ &⑤\max\{R(A),R(B)\}\leq R(A,B)\leq R(A)+R(B).\\ &⑥R(A+B)\leq R(A)+R(B).\\ &⑦R(AB)\leq\min\{R(A),R(B)\}.\\ &⑧若A_{m\times n}B_{n\times l}=O,则R(A)+R(B)\leq n. \end{aligned}§3 线性方程组的解线性方程组如果有解，就称它是相容的，否则称不相容。 定理3 n元线性方程组$Ax=b$ (i)无解的充分必要条件是$R(A)&lt;R(A,b)$; (ii)有惟一解的充分必要条件是$R(A)=R(A,b)=n$； (iii)有无限多解的充分必要条件是$R(A)=R(A,b)&lt;n$。 定理4 n元齐次线性方程组$Ax=0$有非零解的充分必要条件是$R(A)&lt;n$。 定理5 线性方程组$Ax=b$有解的充分必要条件是$R(A)=R(A,b)$。 定理6 矩阵方程$AX=B$有解的充分必要条件是$R(A)=R(A,B)$。 定理7 设$AB=C$，则$R(C)\leq\min{R(A),R(B)}$。]]></content>
      <categories>
        <category>Basics</category>
        <category>Linear Algebra</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第2章 矩阵及其运算]]></title>
    <url>%2F2019%2F02%2F11%2F%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B02%2F</url>
    <content type="text"><![CDATA[§1 线性方程组和矩阵一、线性方程组设有n个未知数m个方程的线性方程组。当常数项不全为零时，线性方程组叫做n元非齐次线性方程组，当常数项全为零时，叫做n元齐次线性方程组 n元齐次线性方程组一定有零解，不一定有非零解。 二、矩阵的定义定义1 由m$\times$n个数$a_{ij}(i=1,2,\dots,m;j=1,2,\dots,n)$排成的m行n列的数表 \begin{matrix} a_{11}&a_{12}&\cdots&a_{1n}\\ a_{21}&a_{22}&\cdots&a_{2n}\\ \vdots&\vdots&&\vdots\\ a_{m1}&a_{m2}&\dots&a_{mn} \end{matrix}称为m行n列矩阵。记作 A= \left( \begin{matrix} a_{11}&a_{12}&\cdots&a_{1n}\\ a_{21}&a_{22}&\cdots&a_{2n}\\ \vdots&\vdots&&\vdots\\ a_{m1}&a_{m2}&\dots&a_{mn} \end{matrix} \right)只有一行(列)的矩阵称为行(列)矩阵或行(列)向量。行数与列数相等的矩阵称为同型矩阵。元素都是0的矩阵称为零矩阵，记作$O$。 对于非齐次线性方程组，有 A=(a_{ij}), x= \left( \begin{matrix} x_1\\ x_2\\ \vdots\\ x_n \end{matrix} \right), b= \left( \begin{matrix} b_1\\ b_2\\ \vdots\\ b_m \end{matrix} \right), B= \left( \begin{matrix} a_{11}&a_{12}&\cdots&a_{1n}&b_1\\ a_{21}&a_{22}&\cdots&a_{2n}&b_2\\ \vdots&\vdots&&\vdots&\vdots\\ a_{m1}&a_{m2}&\dots&a_{mn}&b_m \end{matrix} \right)其中$A$称为系数矩阵，$x$称为未知数矩阵，$b$称为常数项矩阵，$B$称为增广矩阵。 对角线以外的元素都是0的矩阵称为对角矩阵，记作 A=diag(\lambda_1,\lambda_2,\dots,\lambda_n)线性变换与矩阵一一对应。 对角线全是1，其他全0的矩阵称为单位阵$E$，对应的线性变换称为恒等变换。 §2 矩阵的运算一、矩阵的加法定义2 设有两个$m\times n$矩阵$A和B$，它们的和记为$A+B$，规定为 A+B= \left( \begin{matrix} a_{11}+b_{11}&a_{12}+b_{12}&\cdots&a_{1n}+b_{1n}\\ a_{21}+b_{21}&a_{22}+b_{22}&\cdots&a_{2n}+b_{2n}\\ \vdots&\vdots&&\vdots\\ a_{m1}+b_{m1}&a_{m2}+b_{m2}&\dots&a_{mn}+b_{mn} \end{matrix} \right)只有同型矩阵可以进行加法运算，满足交换律和结合律。 二、数与矩阵相乘定义3 数$\lambda$与矩阵$A$的乘积记作$\lambda A$，规定为 \lambda A=A\lambda= \left( \begin{matrix} \lambda a_{11}&\lambda a_{12}&\cdots&\lambda a_{1n}\\ \lambda a_{21}&\lambda a_{22}&\cdots&\lambda a_{2n}\\ \vdots&\vdots&&\vdots\\ \lambda a_{m1}&\lambda a_{m2}&\dots&\lambda a_{mn} \end{matrix} \right)满足结合律和分配律。 三、矩阵与矩阵相乘定义4 设$A$是一个$m\times s$矩阵，$B$是一个$s\times n$矩阵，规定$A与B$的乘积是一个$m\times n$矩阵$C$，其中 c_{ij}=\sum_{k=1}^sa_{ik}b_{kj}(i=1,2,\dots,m;j=1,2,\dots,n) (7)乘积记作$C=AB$，只有当第一个矩阵的列数等于第二个矩阵的行数时，两个矩阵才能相乘。 矩阵乘法不满足交换律，满足结合律和分配律。 四、矩阵的转置定义5 把矩阵$A$的行转换成同序数的列得到一个新矩阵，叫做$A$的转置矩阵，记作$A^T$。满足以下运算规律： \begin{aligned} &(i)(A^T)^T=A;\\ &(ii)(A+B)^T=A^T+B^T;\\ &(iii)(\lambda A)^T=\lambda A^T;\\ &(iv)(AB)^T=B^TA^T. \end{aligned}若$A^T=A$，则$A$称为对称矩阵。 五、方阵的行列式定义6 由n阶方阵$A$的元素所构成的行列式称为方阵$A$的行列式，记作$detA$或$|A|$，满足以下性质： \begin{aligned} &(i)|A^T|=|A|;\\ &(ii)|\lambda A|=\lambda^n|A|;\\ &(iii)|AB|=|A||B|. \end{aligned}行列式$|A|$的各个元素的代数余子式$A_{ij}$所构成的如下的矩阵 A^*= \left( \begin{matrix} A_{11}&A_{21}&\dots&A_{n1}\\ A_{12}&A_{22}&\dots&A_{n2}\\ \vdots&\vdots&&\vdots\\ A_{1n}&A_{2n}&\dots&A_{nn} \end{matrix} \right)称为矩阵$A$的伴随矩阵，有$AA^=A^A=|A|E$。 §3 逆矩阵一、逆矩阵的定义、性质和求法定义7 对于n阶矩阵$A$，如果有一个n阶矩阵$B$，使$AB=BA=E$，则说矩阵$A$是可逆的，并把矩阵$B$称为$A$的逆矩阵，简称逆阵。 如果矩阵A是可逆的，那么A的逆矩阵是唯一的。A的逆矩阵记作$A^{-1}$。 定理1 若矩阵$A​$可逆，则$|A|\neq0​$。 定理2 若$|A|\neq0​$，则矩阵$A​$可逆，且$A^{-1}=\frac{1}{|A|}A^​$，其中$A^​$为矩阵$A​$的伴随矩阵。 当$|A|=0$时，$A$称为奇异矩阵，否则称非奇异矩阵。由上面两定理可知：$A$是可逆矩阵的充分必要条件是$|A|\neq0$，即可逆矩阵就是非奇异矩阵。由定理2，可得下述推论 推论 若$AB=E$(或$BA=E$)，则$B=A^{-1}$ 逆矩阵满足下述运算规律： \begin{aligned} &(i)若A可逆，则A^{-1}亦可逆，且(A^{-1})^{-1}=A;\\ &(ii)若A可逆，数\lambda\neq0，则\lambda A可逆，且(\lambda A)^{-1}=\frac{1}{\lambda}A^{-1};\\ &(iii)若A、B为同阶矩阵且均可逆，则AB亦可逆，且(AB)^{-1}=B^{-1}A^{-1}\\ &(iv)若A可逆，则A^T亦可逆，且(A^T)^{-1}=(A^{-1})^T \end{aligned}二、逆矩阵的初步应用记$\varphi(A)=a_0E+a_1A+\dots+a_mA^m$，称为矩阵A的m次多项式。 \begin{aligned} &如果A=P\Lambda P^{-1}，则A^k=P\Lambda^kP^{-1}，从而\\ &\varphi(A)=a_0E+a_1A+\dots+a_mA^m=Pa_0Ep^{-1}+Pa_1\Lambda P^{-1}+\dots+Pa_m\Lambda^mP^{-1}=P\varphi(\Lambda)p^{-1}.\\ &如果\Lambda=diag(\lambda_1,\lambda_2,\dots,\lambda_n)为对角矩阵，则\Lambda^k=diag(\lambda_1^k,\lambda_2^k,\dots,\lambda_n^k). \end{aligned}§4 克拉默法则克拉默法则 如果线性方程组的系数矩阵$A$的行列式不等于零，即 |A|= \left| \begin{matrix} a_{11}&\dots&a_{1n}\\ \vdots&&\vdots\\ a_{n1}&\dots&a_{nn} \end{matrix} \right|\neq0,那么，方程组有唯一解 x_1=\frac{|A_1|}{|A|},x_2=\frac{|A_2|}{|A|},\dots,x_n=\frac{|A_n|}{|A|},其中$A_j$是把系数矩阵A中第j列的元素用方程组右端的常数项代替后所得到的n阶矩阵，即 A_j= \left( \begin{matrix} a_{11}&\dots&a_{1,j-1}&b_1&a_{1,j+1}&\dots&a_{1n}\\ \vdots&&\vdots&\vdots&\vdots&&\vdots\\ a_{n1}&\dots&a_{n,j-1}&b_n&a_{n,j+1}&\dots&a_{nn} \end{matrix} \right)§5 矩阵分块法将矩阵$A$用若干条纵线和横线分成许多个小矩阵，每一个小矩阵称为$A$的子块，以子块为元素的形式上的矩阵称为分块矩阵。]]></content>
      <categories>
        <category>Basics</category>
        <category>Linear Algebra</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第1章 行列式]]></title>
    <url>%2F2019%2F02%2F09%2F%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B01%2F</url>
    <content type="text"><![CDATA[§1 二阶与三阶行列式定义1 设有9个数排成3行3列的数表 \begin{matrix} a_{11}&a_{12}&a_{13}\\ a_{21}&a_{22}&a_{23}&&&&&(5)\\ a_{31}&a_{32}&a_{33} \end{matrix}记 \left| \begin{matrix} a_{11}&a_{12}&a_{13}\\ a_{21}&a_{22}&a_{23}\\ a_{31}&a_{32}&a_{33}\\ \end{matrix} \right|\\ =a_{11}a_{22}a_{33}+a_{12}a_{23}a_{31}+a_{13}a_{21}a_{32}-a_{11}a_{23}a_{32}-a_{12}a_{21}a_{33}-a_{13}a_{22}a_{31},(6)(6)式称为数表(5)所确定的三阶行列式 §2 全排列和对换一、排列及其逆序数对于n个不同元素规定一个标准次序，n个元素任一排列中当某对元素先后次序与标准次序不同时，构成一个逆序，逆序的总数叫做这个排列的逆序数。 逆序数为奇数的叫奇排列，反之为偶排列。 二、对换排列中，将任意两元素对调，其余元素不动，称为对换。 定理1 一个排列中的任意两个元素对换，排列改变奇偶性。 推论 奇排列对换成标准排列的对换次数为奇数，偶排列对换成标准排列的对换次数为偶数。 §3 n阶行列式的定义定义2 设有$n^2$个数，排成n行n列的数表 \begin{matrix} a_{11}&a_{12}&\cdots&a_{1n}\\ a_{21}&a_{22}&\cdots&a_{2n}\\ &\dots&\dots\\ a_{n1}&a_{n2}&\dots&a_{nn} \end{matrix}作出表中位于不同行不同列的n个数的乘积，并冠以符号$(-1)^t$，得到形如 (-1)^ta_{1p_1}a_{2p_2}\dots a_{np_n} (7)的项，其中$p_1p_2\dots p_n$为自然数$1,2,\dots,n$的一个排列，t为这个排列的逆序数.由于这样的排列共有$n!$个，因而形如(7)式的项共有$n!$项。它们的代数和 \sum(-1)^ta_{1p_1}a_{2p_2}\dots a_{np_n}称为n阶行列式，记作 D= \left| \begin{matrix} a_{11}&a_{12}&\cdots&a_{1n}\\ a_{21}&a_{22}&\cdots&a_{2n}\\ \vdots&\vdots&&\vdots\\ a_{n1}&a_{n2}&\dots&a_{nn} \end{matrix} \right|简记$det(a{ij})$，其中数$a{ij}$为行列式D的(i,j)元。 主对角线以上(下)元素都为0的行列式叫上(下)三角行列式；主对角线上下元素都为0的行列式叫对角行列式。 上下三角行列式与对角行列式值都为主对角线上值相乘。 §4 行列式的性质记 D= \left| \begin{matrix} a_{11}&a_{12}&\cdots&a_{1n}\\ a_{21}&a_{22}&\cdots&a_{2n}\\ \vdots&\vdots&&\vdots\\ a_{n1}&a_{n2}&\dots&a_{nn} \end{matrix} \right| ,D^T= \left| \begin{matrix} a_{11}&a_{21}&\cdots&a_{n1}\\ a_{12}&a_{22}&\cdots&a_{n2}\\ \vdots&\vdots&&\vdots\\ a_{1n}&a_{2n}&\dots&a_{nn} \end{matrix} \right|行列式$D^T$称为行列式D的转置行列式。 性质1 行列式与它的转置行列式相等 由此性质可知，行列式的性质凡是对行成立的对列也同样成立，反之亦然。 性质2 对换行列式的两行(列)，行列式变号。 推论 如果行列式有两行(列)完全相同，则此行列式等于零。 性质3 行列式的某一行(列)中所有的元素都乘同一数k，等于用数k乘此行列式。 推论 行列式中某一行(列)所有元素的公因子可以提到行列式记号的外面。 性质4 行列式中如果有两行(列)元素成比例，则此行列式等于零。 性质5 若行列式的某一行(列)的元素都是两数之和，例如第i行的元素都是两数之和： D= \left| \begin{matrix} a_{11}&a_{12}&\dots&a_{1n}\\ \vdots&\vdots&&\vdots\\ a_{i1}+a_{i1}^{'}&a_{i2}+a_{i2}^{'}&\dots&a_{in}+a_{in}^{'}\\ \vdots&\vdots&&\vdots\\ a_{n1}&a_{n2}&\dots&a_{nn} \end{matrix} \right|则D等于下列两个行列式之和： D= \left| \begin{matrix} a_{11}&a_{12}&\dots&a_{1n}\\ \vdots&\vdots&&\vdots\\ a_{i1}&a_{i2}&\dots&a_{in}\\ \vdots&\vdots&&\vdots\\ a_{n1}&a_{n2}&\dots&a_{nn} \end{matrix} \right|+ \left| \begin{matrix} a_{11}&a_{12}&\dots&a_{1n}\\ \vdots&\vdots&&\vdots\\ a_{i1}^{'}&a_{i2}^{'}&\dots&a_{in}^{'}\\ \vdots&\vdots&&\vdots\\ a_{n1}&a_{n2}&\dots&a_{nn} \end{matrix} \right|性质6 把行列式某一行(列)的各元素乘同一数然后加到另一行(列)对应的元素上去，行列式不变。 任何行列式总能化为上(下)三角行列式。 §5 行列式按行(列)展开在n阶行列式中，把(i,j)元$a{ij}$所在的第i行和第j列划去后，留下来的n-1阶行列式叫做(i,j)元$a{ij}$的余子式，记作$M{ij}$；记$A{ij}=(-1)^{i+j}M{ij}$，叫做$a{ij}$的代数余子式。 引理 一个n阶行列式，如果其中第i行所有元素除(i,j)元$a{ij}$外都为零，那么这行列式等于$a{ij}$与它的代数余子式的乘积，即$D=a{ij}A{ij}$ 定理2 行列式等于它的任一行(列)的各元素与其对应的代数余子式乘积之和 范德蒙德(Vandermonde)行列式 D_n= \left| \begin{matrix} 1&1&\dots&1\\ x_1&x_2&\dots&x_n\\ x_1^2&x_2^2&\dots&x_n^2\\ \vdots&\vdots&&\vdots\\ x_1^{n-1}&x_2^{n-1}&\dots&x_n^{n-1} \end{matrix} \right|= \prod_{n\geq i>j\geq1}(x_i-x_j), (8)推论 行列式某一行(列)的元素与另一行(列)的对应元素的代数余子式乘积之和等于零。]]></content>
      <categories>
        <category>Basics</category>
        <category>Linear Algebra</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Note of Machine Learning 2]]></title>
    <url>%2F2019%2F01%2F27%2FML2%2F</url>
    <content type="text"><![CDATA[第2章 模型评估与选择2.1 经验误差与过拟合错误率(error rate) and 精度(accuracy)：分类错误的样本数占样本总数的比例称为“错误率”，如果在m个样本中有a个样本分类错误，则错误率E=a/m；相应的1-a/m称为“精度”。 误差(error)：学习器的实际预测输出与样本的真实输出之间的差异。 训练误差(training error) or 经验误差(empirical error)：学习器在训练集上的误差。 泛化误差(generalization error)：学习器在新样本上的误差。 过拟合(overfitting) and 欠拟合(underfitting)：学习器把训练样本自身的一些特点当作了所有潜在样本都会具有的一般性质，导致泛化性能下降的现象称为“过拟合”，相对的，“欠拟合”指对训练样本的一般性质尚未学好。 欠拟合比较容易克服，过拟合是机器学习面临的关键障碍。过拟合是无法彻底避免的，只能减小其风险。可以这样理解：机器学习面临的问题通常是NP难甚至更难，而有效的学习算法必然是在多项式时间内运行完成，若可彻底避免过拟合，则通过经验误差最小化就能获最优解，这就意味着我们构造性地证明了“P=NP”；因此，只要相信”P$\neq​$NP“，过拟合就不可避免。 模型选择(model selection)：现实任务中，往往有多种学习算法可供选择，对同一个学习算法，使用不同的参数配置时，也会产生不同的模型。选用哪一个学习算法、使用哪一种参数配置的问题，称为”模型选择“问题。 2.2 评估方法通常，我们可通过实验测试来对学习器的泛化误差进行评估并进而做出选择。为此，需使用一个“测试集”(testing set)来测试学习器对新样本的判别能力，然后以测试集上的“测试误差”(testing error)作为泛化误差的近似。 测试集应尽可能与训练集互斥。有一个包含m个样例的数据集D = {(x1,y1),(x2,y2),…,(xm,ym)}，通过对D进行适当的处理，从中产生训练集S和测试集T。下面介绍几种常见做法。 2.2.1 留出法留出法(hold-out)：直接将数据集D划分为两个互斥的集合，其中一个集合作为训练集S，另一个作为训练集T，即D = S $\cup$ T, S $\cap$ T = $\varnothing$。在S上训练出模型后，用T来评估其测试误差，作为对泛化误差的估计。 需注意的是，训练/测试集的划分要尽可能保持数据分布的一致性，避免因数据划分过程引入额外的偏差而对最终结果产生影响。 另一个需注意的问题是，即便在给定训练/测试集的样本比例后，仍存在多种划分方式对初始数据集D进行分割。因此，单次留出法得到的估计结果往往不够稳定可靠，在使用留出法时，一般要采用若干次随机划分，重复进行实验评估后取平均值作为留出法的评估结果。 留出法会导致一个窘境：若令训练集S包含绝大多数样本，则训练出的模型可能更接近于用D训练出的模型，但由于T比较小，评估结果可能不够稳定准确；若令测试集T多包含一些样本，则训练集S与D差别更大了，被评估的模型与用D训练出的模型相比可能有较大差别，从而降低了评估结果的保真性(fidelity)。这个问题没有完美的解决方案。 2.2.2 交叉验证法交叉验证法(cross validation)：先将数据集D划分为k个大小相似的互斥子集，即D = D1 $\cup$ D2 $\cup$ … $\cup$ Dk，Di $\cap$ Dj = $\varnothing$ (i$\neq$j)。每个子集Di都尽可能保持数据分布的一致性，即从D中通过分层采样得到。然后，每次用k - 1个子集的并集作为训练集，余下的那个子集作为测试集；这样就可获得k组训练/测试集，从而可进行k次训练和测试，最终返回的是这k个测试结果的均值。 显然，交叉验证法评估结果的稳定性和保真性在很大程度上取决于k的取值，为强调这一点，通常把交叉验证法称为“k折交叉验证”(k-fold cross validation)。 与留出法相似，将数据集D划分为k个子集同样存在多种划分方式。为减小因样本划分不同而引入的差别，k折交叉验证通常要随机使用不同的划分重复p次，最终的评估结果是这p次k折交叉验证的结果的均值。 假定数据集D中包含m个样本，若令k = m，则得到了交叉验证法的一个特例：留一法(Leave-One-Out，简称LOO)。留一法结果比较准确，但数据集比较大时，计算开销难以忍受。 2.2.3 自助法自助法(bootstrapping)：给定包含m个样本的数据集D，对它进行采样产生数据集D’：每次随机从D中挑选一个样本，将其拷贝放入D‘，然后再将该样本放回初始数据集D中；这个过程重复执行m次，得到包含m个样本的数据集D’。样本在m次采样中始终不被采到的概率是 lim_{m\rightarrow\infty}(1-\frac{1}{m})^m=\frac{1}{e}\approx0.368 (2.1)即通过自助采样，初始数据集D中约有36.8%的样本未出现在采样数据集D’中。将D’用作训练集，D\D’用作测试集；这样的测试结果，亦称“包外估计”(out-of-bagestimate)。 自助法在数据集较小、难以有效划分训练/测试集时很有用，但会引入估计偏差。初始数据量足够时，留出法和交叉验证法更常用一些。 2.2.4 调参与最终模型大多数学习算法都有些参数(parameter)需要设定，在进行模型评估与选择时，除了要对适用学习算法进行选择，还需对算法参数进行设定，这就是“调参”(parameter tuning)。 通常把学得模型在实际使用中遇到的数据称为测试数据，模型评估与选择中用于评估测试的数据集常称为“验证集”(validation set)。 2.3 性能度量对学习器的泛化性能进行评估，不仅需要有效可行的实验估计方法，还需要有衡量模型泛化能力的评价标准，这就是性能度量(performance measure)。 在预测任务中，给定样例集D = {(x1,y1),(x2,y2),…,(xm,ym)}，其中yi是示例xi的真实标记。要评估学习器f的性能，就要把学习器预测结果f(x)与真实标记y进行比较。 回归任务最常用的性能度量是“均方误差”(mean squared error) E(f;D)=\frac{1}{m}\sum_{i=1}^{m}(f(x_i)-y_i)^2. (2.2)更一般的，对于数据分布$\mathcal{D}$和概率密度函数p($\cdot$)，均方误差可描述为 E(f;\mathcal{D})=\int_{x\sim\mathcal{D}}(f(x)-y)^2p(x)dx. (2.3)下面介绍分类任务中常用的性能度量。 2.3.1 错误率与精度错误率是分类错误的样本占样本总数的比例，精度则是分类正确的样本数占样本总数的比例。对样例集D，分类错误率定义为 E(f;D)=\frac{1}{m}\sum_{i=1}^{m}\mathbb{I}(f(x_i\neq y_i)). (2.4)精度则定义为 \begin{aligned} acc(f;D)&=\frac{1}{m}\sum_{i=1}^m\mathbb{I}(f(x_i)=y_i) (2.5)\\ &=1-E(f;D). \end{aligned}更一般的，对于数据分布$\mathcal{D}$和概率密度函数p($\cdot$)，错误率与精度可分别描述为 E(f;\mathcal{D})=\int_{x\sim\mathcal{D}}\mathbb{I}(f(x)\neq y)p(x)dx, (2.6) \begin{aligned} acc(f;\mathcal{D})&=\int_{x\sim\mathcal{D}}\mathbb{I}(f(x)=y)p(x)dx, (2.7)\\ &=1-E(f;\mathcal{D}) \end{aligned}2.3.2 查准率、查全率与F1错误率与精度不能满足所有任务需求，因此引入“查准率”(precision)与“查全率”(recall)。 对于二分类问题，可将样例根据其真实类别与学习器预测类别的组合划分为真正例(true positive)、假正例(false positive)、真反例(true negative)、假反例(false negative)，令TP、FP、TN、FN分别表示其对应的样例数，则显然后TP+FP+TN+FN=样例总数。分类结果的“混淆矩阵”(confusion matrix)如下 查准率P与查全率R分别定义为 P=\frac{TP}{TP+FP}, (2.8)\\ R=\frac{TP}{TP+FN}. (2.9)查准率和查全率是一对矛盾的度量。根据学习器的预测结果对样例进行排序，逐个把样本作为正例进行预测，则每次可以计算出当前的查全率、查准率。以查准率为纵轴，查全率为横轴作图，就得到了“P-R曲线“。 ”平衡点“(Break-Even Point，简称BEP)是”查准率=查全率“时的取值，用于度量学习器的优劣。 F1度量： F1=\frac{2\times P\times R}{P+R}=\frac{2\times TP}{样例总数+TP-TN}. (2.10)F1度量的一般形式——F$\beta$，能表达出对查准率、查全率的不同偏好： F_\beta=\frac{(1+\beta^2)\times P\times R}{(\beta^2\times P)+R}, (2.11)$\beta$ &gt; 0度量了查全率对查准率的相对重要性。$\beta$ = 1时退化为标准的F1；$\beta$ &gt; 1时查全率有更大影响；$\beta$ &lt; 1时查准率有更大影响。 有多个混淆矩阵时，一种做法是在各混淆矩阵上分别计算出查准率和查全率，再计算平均值，得到”宏查准率“(macro-P)、”宏查全率“(macro-R)，”宏F1”(macro-F1)： macroP=\frac{1}{n}\sum_{i=1}^nP_i, (2.12)\\ macroR=\frac{1}{n}\sum_{i=1}^nR_i, (2.13)\\ macroF1=\frac{2\times macroP\times macroR}{macroP+macroR}. (2.14)还可先将各混淆矩阵的对应元素进行平均，再基于这些平均值计算出“微查准率”(micro-P)、“微查全率”(micro-R)和“微F1”(micro-F1)。 microP=\frac{\overline{TP}}{\overline{TP}+\overline{FP}}, (2.15)\\ microR=\frac{\overline{TP}}{\overline{TP}+\overline{FN}}, (2.16)\\ microF1=\frac{2\times microP\times microR}{microP+microR}. (2.17)2.3.3 ROC与AUCROC全称“受试者工作特征”(Receiver Operating Characteristic)曲线。以“真正利率”(True Positive Rata，简称TPR)为纵轴，“假正例率”(False Positive Rate，简称FPR)为横轴，两者分别定义为： TPR=\frac{TP}{TP+FN}, (2.18)\\ FPR=\frac{FP}{TN+FP}. (2.19) 现实任务中测试样例有限，无法产生光滑ROC曲线，只能绘制出近似ROC曲线。 AUC(Area Under ROC Curve)，即ROC曲线下的面积，用于比较学习器的优劣，可估算为： AUC=\frac{1}{2}\sum_{i=1}^{m-1}(x_{i+1}-x_i)\cdot(y_i+y_{i+1}). (2.20)形式化地看，AUC考虑的是样本预测的排序质量，与排序误差有紧密联系。给定m+个正例和m-个反例，另D+和D-分别表示正、反例集合，则排序“损失”(loss)定义为： \mathscr{L}_{rank}=\frac{1}{m^+m^-}\sum_{x^+\in D^+}\sum_{x^-\in D^-}(\mathbb{I}(f(x^+)]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1056 排座椅]]></title>
    <url>%2F2019%2F01%2F26%2F%E6%B4%9B%E8%B0%B7P1056%2F</url>
    <content type="text"><![CDATA[Description上课的时候总会有一些同学和前后左右的人交头接耳，这是令小学班主任十分头疼的一件事情。不过，班主任小雪发现了一些有趣的现象，当同学们的座次确定下来之后，只有有限的D对同学上课时会交头接耳。 同学们在教室中坐成了M行N列，坐在第i行第j列的同学的位置是(i,j)(i,j)，为了方便同学们进出，在教室中设置了K条横向的通道，L条纵向的通道。 于是，聪明的小雪想到了一个办法，或许可以减少上课时学生交头接耳的问题：她打算重新摆放桌椅，改变同学们桌椅间通道的位置，因为如果一条通道隔开了2个会交头接耳的同学，那么他们就不会交头接耳了。 请你帮忙给小雪编写一个程序，给出最好的通道划分方案。在该方案下，上课时交头接耳的学生的对数最少。 Input第一行，有5个用空格隔开的整数，分别是M,N,K,L,D(2 $\leq$ N,M $\leq$ 1000,0 $\leq$ K&lt;M,0 $\leq$ L&lt;N,D $\leq$ 2000) 接下来的D行，每行有4个用空格隔开的整数。第i行的4个整数Xi,Yi,Pi,Qi，表示坐在位置(Xi,Yi)与(Pi,Qi)的两个同学会交头接耳（输入保证他们前后相邻或者左右相邻）。 输入数据保证最优方案的唯一性。 Output共两行。第一行包含K个整数a1,a2,…,aK，表示第a1行和a1+1行之间、第a2行和a2+1行之间、…、第aK行和第aK+1行之间要开辟通道，其中ai&lt;ai+1，每两个整数之间用空格隔开（行尾没有空格）。 第二行包含L个整数b1,b2,…,bL，表示第b1列和b1+1列之间、第b2列和b2+1列之间、…、第bL列和第bL+1列之间要开辟通道，其中bi&lt;bi+1，每两个整数之间用空格隔开（列尾没有空格）。 Sample Input12344 5 1 2 34 2 4 32 3 3 32 5 2 4 Sample Output1222 4 Analysis先想一下算法：因为题目里出现了“最优解”，“最好的方案”关键字，所以一定会用贪心。然后从题目给的样例解释可以看到：如果相邻的两行有许多组说话的同学，那么在这两行中间加一条过道是非常划算的；同理，列也是如此。 恍然大悟，只要找出划分哪些相邻的两行和相邻的两列可以隔开的同学最多，此题可解。 接下来是找规律： 我们先定义两个数组x,y,x[1]表示如果在第一列与第二列中间划分过道能够分开几组说话的同学,同理,x[2]则是第二列与第三列… 直到x[n-1] .y[1]表示第一行与第二行，y[2]表示第二行与第三行… 直到y[m-1] 题目输入两个同学的坐标，如果横坐标相同，即这两个同学在一行，那么设两个同学纵坐标分别为a,b 如果a&lt;b 那么x[a]++ 否则x[b]++（这里一定要特判一下a和b的大小） 同理y数组也如此操作即可。 最后x,y数组分别扫一遍，然后桶排一下即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;int m, n, k, l, d;int a[1005], b[1005];int x[1005], y[1005];int main()&#123; while (cin &gt;&gt; m &gt;&gt; n &gt;&gt; k &gt;&gt; l &gt;&gt; d) &#123; memset(a, 0, sizeof(a)); memset(b, 0, sizeof(b)); memset(x, 0, sizeof(x)); memset(y, 0, sizeof(y)); for (int i = 1; i &lt;= d; i++) &#123; int xi, yi, pi, qi; cin &gt;&gt; xi &gt;&gt; yi &gt;&gt; pi &gt;&gt; qi; if (xi == pi) a[min(yi, qi)]++; else b[min(xi, pi)]++; &#125; for (int i = 1; i &lt;= k; i++) &#123; int maxn = -1; int p; for (int j = 1; j &lt; m; j++) &#123; if (b[j] &gt; maxn) &#123; maxn = b[j]; p = j; &#125; &#125; b[p] = 0; x[p]++; &#125; for (int i = 1; i &lt;= l; i++) &#123; int maxn = -1; int p; for (int j = 1; j &lt; n; j++) &#123; if (a[j] &gt; maxn) &#123; maxn = a[j]; p = j; &#125; &#125; a[p] = 0; y[p]++; &#125; int i = 0, j = 0; for (i; i &lt; 1005; i++) &#123; if (x[i]) &#123; cout &lt;&lt; i; break; &#125; &#125; i++; for (i; i &lt; 1005; i++) &#123; if (x[i]) cout &lt;&lt; " " &lt;&lt; i; &#125; cout &lt;&lt; endl; for (j; j &lt; 1005; j++) &#123; if (y[j]) &#123; cout &lt;&lt; j; break; &#125; &#125; j++; for (j; j &lt; 1005; j++) &#123; if (y[j]) cout &lt;&lt; " " &lt;&lt; j; &#125; cout &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Greedy</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Note of Machine Learning 1]]></title>
    <url>%2F2019%2F01%2F26%2FML1%2F</url>
    <content type="text"><![CDATA[第1章 绪论1.1 引言机器学习是这样一门学科，它致力于研究如何通过计算的手段，利用经验来改善系统自身的性能。在计算机系统中，”经验“通常以”数据“形式存在，因此，机器学习所研究的主要内容，是关于在计算机上从数据中产生”模型“(model)的算法，即”学习算法“(learning algorithm)。有了学习算法，我们把经验数据提供给它，它就能基于这些数据产生模型；在面对新的情况时，模型会给我们提供相应的判断。 [Mitchell,1997]给出了一个更形式化的定义：假设用P来评估计算机程序在某任务类T上的性能，若一个程序通过利用经验E在T中任务上获得了性能改善，则我们说关于T和P，该程序对E进行了学习。 1.2 基本术语数据集(data set)：一组数据记录的集合。 示例(instance) or 样本(sample)：关于一个事件或对象的描述的一条记录。 属性(attribute) or 特征(feature)：反映事件或对象在某方面的表现或性质的事项。 属性值(attribute value)：属性上的取值。 属性空间(attribute space) or 样本空间(sample space) or 输入空间：属性张成的空间。 特征向量(feature vector)：属性空间中每个点对应的坐标向量。 维数(dimensionality)：令D = {x1,x2,…,xm}表示包含m个示例的数据集，每个示例由d个属性描述，则每个示例 xi = (xi1;xi2;…;xid)是d维空间χ中的一个向量，xi $\in$ χ，其中xij是xi在第j个属性上的取值，d称为样本xi的“维数”。 学习(learning) or 训练(training)：从数据中学的模型的过程，这个过程通过执行某个学习算法来完成。 训练数据(training data)：训练过程中使用的数据。 训练样本(training sample)：训练过程中每个样本。 训练集(training set)：训练样本组成的集合。 假设(hypothesis)：学得模型对应了关于数据的某种潜在的规律。 真相 or 真实(ground-truth)：潜在规律自身，学习过程就是为了找出或逼近真相。 标记(label)：关于示例结果的信息。 样例(example)：拥有了标记信息的示例。 标记空间(label space) or 输出空间：用(xi,yi)表示第i个样例，其中yi $\in$ γ是xi的标记，γ是所有标记的集合，亦称“标记空间”或“输出空间”。 分类(classification)：欲预测的是离散值时的学习任务。 回归(regression)：欲预测的是连续值时的学习任务。 二分类(binary classification) and 多分类(multi-class classification)：只涉及两个/多个类别的任务。 正类(positive class) and 反类(negative class)：二分类任务其中一个类和另一个类。 测试(testing) and 测试样本(testing sample)：学得模型后，使用其进行预测的过程称为“测试”，被预测的样本称为“测试样本”。 聚类(clustering) and 簇(cluster)：对数据做“聚类”，即将数据分成若干组，每组称为一个“簇”，这些自动形成的簇可能对应一些潜在的概念划分。 监督学习(supervised learning) and 无监督学习(unsupervised learning)：根据训练数据是否拥有标记信息，学习任务可大致划分为“监督学习”和“无监督学习”，分类和回归是前者的代表，聚类是后者的代表。 泛化(generalization)能力：学得模型适用于新样本的能力。 独立同分布(independent and identically distributed,简称i.i.d)：假设样本空间中全体样本服从一个未知“分布”(distribution)，我们获得的每个样本都是独立地从这个分布上采样获得的，即“独立同分布”。 1.3 假设空间我们可以把学习过程看作一个在所有假设(hypothesis)组成的空间中进行搜索的过程，搜索目标是找到与训练集“匹配”(fit)的假设，即能够将训练集中的瓜判断正确的假设。假设的表示一旦确定，假设空间及其规模大小就确定了。 可以有许多策略对假设空间进行搜索，搜索过程中不断删除与正例不一致的假设或与反例一致的假设。最终将会获得与训练集一致(即对所有训练样本能够进行正确判断)的假设，这就是我们学得的结果。 需要注意的是，现实问题中我们常面临很大的假设空间，但学习过程是基于有样本训练集进行的，因此，可能有多个假设与训练集一致，即存在一个与训练集一致的“假设集合”，我们称之为“版本空间”(version space)。 1.4 归纳偏好当版本空间有多个假设与训练集一致，但与它们对应的模型在面临新样本的时候，会产生不同的输出，那么应该采用哪一个模型呢？ 机器学习算法在学习过程中对某种类型假设的偏好，称为“归纳偏好”(inductive vias)，或简称为“偏好”。任何一个有效的机器学习算法必有其归纳偏好，否则它将被假设空间中看似在训练集上“等效”的假设所迷惑，而无法产生确定的学习结果。那么有没有一般性的原则来引导算法确立“正确的”偏好呢？ “奥卡姆剃刀”(Occam’s razor)是一种常用的、自然科学研究中最基本的原则，即“若有多个假设与观察一致，则选最简单的那个”。然而其并非唯一可行的原则。 “没有免费的午餐”定理(No Free Lunch Theorem,简称NFL定理)[Wolpert,1996;Wolpert and Macready,1995]： 设有学习算法ζa和ζb，假设样本空间χ和假设空间H都是离散的。令P(h|X,ζa)代表算法ζa基于训练数据X产生假设h的概率，再令f代表我们希望学习的真实目标函数。ζa的“训练集外误差”，即ζa在训练集之外的所有样本上的误差为 Eote(ζ_a|X,f)=\sum_h\sum_{x\inχ-x}P(x)\mathbb{I}(h(x)\neq f(x))P(h|X,ζ_a) (1.1)其中$\mathbb{I}$(•)是指示函数，若•为真则取值1，否则取值0。 考虑二分类问题，且真实目标函数可以是任何函数χ $\mapsto​${0,1}，函数空间为{0,1}|χ|。对于所有可能的f按均匀分布对误差求和，有 \begin{aligned} \sum_fEote(ζ_a|X,f)&=\sum_f\sum_h\sum_{x\inχ-X}P(x)\mathbb{I}(h(x)\neq f(x))P(h|X,ζ_a)\\ &=\sum_{x\inχ-X}P(x)\sum_hP(h|X,ζ_a)\sum_fⅡ(h(x)\neq f(x))\\ &=\sum_{x\inχ-X}P(x)\sum_hP(h|X,ζ_a)\frac{1}{2}2^{|χ|}\\ &=\frac{1}{2}2^{|χ|}\sum_{x\inχ-X}P(x)\sum_hP(h|X,ζ_a)\\ &=2^{|χ|-1}\sum_{x\inχ-X}P(x)\cdot1 (1.2) \end{aligned}式(1.2)显示出，总误差与学习算法无关，对于任意两个学习算法ζa和ζb，有 \sum_fEote(ζ_a|X,f)=\sum_fEote(ζ_b|X,f) (1.3)这就是“没有免费的午餐”定理。 需注意到，NFL定理有一个重要前提：所有“问题”出现的机会相同、或所有问题同等重要。所以，其最重要的寓意，是让我们清楚地认识到，脱离具体问题，空谈“什么学习算法更好”毫无意义。学习算法自身的归纳偏好与问题是否匹配，往往会起到决定性的作用。]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Threaded Binary Tree]]></title>
    <url>%2F2018%2F12%2F20%2F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91(Threaded%20BinaryTree)%2F</url>
    <content type="text"><![CDATA[线索二叉树的定义、实现、三种线索化方式以及其对应的遍历方式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213#include &lt;iostream&gt;using namespace std;typedef struct BiThrNode &#123;//线索二叉树的结点 int data;//数据域 BiThrNode *lchild, *rchild;//左右孩子指针 BiThrNode *parent; int LTag = 0, RTag = 0;//左右标志&#125;BiThrNode, *BiThrTree;class ThreadBiTree &#123;private: BiThrNode *bt;//根结点 BiThrNode *pre; void RCreate(BiThrNode *p, int k, int end);public: BiThrNode *Thrt;//头结点 ThreadBiTree() &#123; bt = NULL; pre = NULL; Thrt = new BiThrNode; &#125;//构造函数，对二叉链表进行初始化 void CreateBiTree(int end); BiThrNode *Getroot();//二叉树不为空获取根结点指针，否则返回NULL void BiTreeDisplay(BiThrNode *bt, int level);//二叉树的树形显示算法 void PreThreading(BiThrTree p);//先序线索化递归函数 int PreOrderThreading(BiThrTree &amp;Thrt, BiThrTree T);//先序遍历进行先序线索化 int PreOrderTraverse_Thr(BiThrTree T);//先序遍历线索二叉树的非递归算法 void InThreading(BiThrTree p);//中序线索化递归函数 int InOrderThreading(BiThrTree &amp;Thrt, BiThrTree T);//中序遍历进行中序线索化 int InOrderTraverse_Thr(BiThrTree T);//中序遍历线索二叉树的非递归算法 void PostThreading(BiThrTree p);//后序线索化递归函数 int PostOrderTraverse_Thr(BiThrTree T);//后序遍历线索二叉树的非递归算法&#125;;void ThreadBiTree::RCreate(BiThrNode * p, int k, int end) &#123; BiThrNode *q; int e; cin &gt;&gt; e; if (e != end) &#123; q = new BiThrNode; q-&gt;data = e; q-&gt;lchild = NULL; q-&gt;rchild = NULL; q-&gt;parent = p; if (k == 1) p-&gt;lchild = q; if (k == 2) p-&gt;rchild = q; RCreate(q, 1, end); RCreate(q, 2, end); &#125;&#125;void ThreadBiTree::CreateBiTree(int end) &#123; cout &lt;&lt; "请按先序序列的顺序输入二叉树，0为空指针域标志：" &lt;&lt; endl; BiThrNode *p; int e; cin &gt;&gt; e; if (e == end) return; p = new BiThrNode; if (!p) &#123; cout &lt;&lt; "申请内存失败！" &lt;&lt; endl; exit(-1); &#125; p-&gt;data = e; p-&gt;lchild = NULL; p-&gt;rchild = NULL; bt = p; RCreate(p, 1, end); RCreate(p, 2, end);&#125;BiThrNode * ThreadBiTree::Getroot() &#123; if (bt != NULL) return bt; return NULL;&#125;void ThreadBiTree::BiTreeDisplay(BiThrNode * bt, int level) &#123; if (bt) &#123; BiTreeDisplay(bt-&gt;rchild, level + 1); for (int i = 0; i &lt; level; i++) cout &lt;&lt; " "; cout &lt;&lt; bt-&gt;data &lt;&lt; endl; BiTreeDisplay(bt-&gt;lchild, level + 1); &#125;&#125;void ThreadBiTree::PreThreading(BiThrTree p) &#123; if (p) &#123; if (!p-&gt;lchild) p-&gt;LTag = 1, p-&gt;lchild = pre; if (pre != NULL &amp;&amp; !pre-&gt;rchild) pre-&gt;RTag = 1, pre-&gt;rchild = p; pre = p; if (p-&gt;LTag == 0) PreThreading(p-&gt;lchild); if (p-&gt;RTag == 0) PreThreading(p-&gt;rchild); &#125;&#125;int ThreadBiTree::PreOrderThreading(BiThrTree &amp; Thrt, BiThrTree T) &#123; Thrt-&gt;LTag = 0; Thrt-&gt;RTag = 1; Thrt-&gt;rchild = Thrt; if (!T) Thrt-&gt;lchild = Thrt; else &#123; Thrt-&gt;lchild = T; pre = Thrt; PreThreading(T); pre-&gt;rchild = Thrt; pre-&gt;RTag = 1; Thrt-&gt;rchild = pre; &#125; return 1;&#125;int ThreadBiTree::PreOrderTraverse_Thr(BiThrTree T) &#123; BiThrNode *p; p = T-&gt;lchild; while (p != T) &#123; while (p-&gt;lchild != NULL &amp;&amp; p-&gt;LTag == 0) &#123; cout &lt;&lt; p-&gt;data &lt;&lt; " "; p = p-&gt;lchild; &#125; cout &lt;&lt; p-&gt;data &lt;&lt; " "; if (p-&gt;LTag == 1) p = p-&gt;rchild; &#125; return 1;&#125;void ThreadBiTree::InThreading(BiThrTree p) &#123; if (p) &#123; InThreading(p-&gt;lchild); if (!p-&gt;lchild) p-&gt;LTag = 1, p-&gt;lchild = pre; if (!pre-&gt;rchild) pre-&gt;RTag = 1, pre-&gt;rchild = p; pre = p; InThreading(p-&gt;rchild); &#125;&#125;int ThreadBiTree::InOrderThreading(BiThrTree &amp; Thrt, BiThrTree T) &#123; Thrt-&gt;LTag = 0; Thrt-&gt;RTag = 1;//Thrt指向头结点 Thrt-&gt;rchild = Thrt; if (!T) Thrt-&gt;lchild = Thrt; else &#123; Thrt-&gt;lchild = T; pre = Thrt; InThreading(T); pre-&gt;rchild = Thrt; pre-&gt;RTag = 1; Thrt-&gt;rchild = pre; &#125; return 1;&#125;int ThreadBiTree::InOrderTraverse_Thr(BiThrTree T) &#123; BiThrNode *p; p = T-&gt;lchild; while (p != T) &#123; while (p-&gt;LTag == 0) p = p-&gt;lchild; cout &lt;&lt; p-&gt;data &lt;&lt; " "; while (p-&gt;RTag == 1 &amp;&amp; p-&gt;rchild != T) &#123; p = p-&gt;rchild; cout &lt;&lt; p-&gt;data &lt;&lt; " "; &#125; p = p-&gt;rchild; &#125; return 1;&#125;void ThreadBiTree::PostThreading(BiThrTree p) &#123; if (p) &#123; PostThreading(p-&gt;lchild); PostThreading(p-&gt;rchild); if (!p-&gt;lchild) p-&gt;LTag = 1, p-&gt;lchild = pre; if (pre &amp;&amp; !pre-&gt;rchild) pre-&gt;RTag = 1, pre-&gt;rchild = p; pre = p; &#125;&#125;int ThreadBiTree::PostOrderTraverse_Thr(BiThrTree T) &#123; if (T) &#123; BiThrTree p = T; pre = NULL; while (pre != T) &#123; while (p-&gt;LTag == 0) p = p-&gt;lchild; while (p&amp;&amp;p-&gt;RTag == 1) &#123; cout &lt;&lt; p-&gt;data &lt;&lt; " "; pre = p; p = p-&gt;rchild; &#125; while (pre != T &amp;&amp; p-&gt;rchild == pre) &#123; cout &lt;&lt; p-&gt;data &lt;&lt; " "; pre = p; if (pre != T)p = p-&gt;parent; &#125; if (p-&gt;RTag == 0)p = p-&gt;rchild; &#125; &#125; return 1;&#125;int main() &#123; ThreadBiTree TA; TA.CreateBiTree(0); TA.BiTreeDisplay(TA.Getroot(), 0); TA.PreOrderThreading(TA.Thrt, TA.Getroot()); cout &lt;&lt; "先序遍历先序线索二叉树："; TA.PreOrderTraverse_Thr(TA.Thrt); cout &lt;&lt; endl; ThreadBiTree TB; TB.CreateBiTree(0); TB.BiTreeDisplay(TB.Getroot(), 0); TB.InOrderThreading(TB.Thrt, TB.Getroot()); cout &lt;&lt; "中序遍历中序线索二叉树："; TB.InOrderTraverse_Thr(TB.Thrt); cout &lt;&lt; endl; ThreadBiTree TC; TC.CreateBiTree(0); TC.BiTreeDisplay(TC.Getroot(), 0); TC.PostThreading(TC.Getroot()); cout &lt;&lt; "后序遍历后序线索二叉树："; TC.PostOrderTraverse_Thr(TC.Getroot()); cout &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>Data Structure</category>
        <category>Binary Tree</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Graph]]></title>
    <url>%2F2018%2F12%2F18%2F%E5%9B%BE(Graph)%2F</url>
    <content type="text"><![CDATA[图的邻接矩阵存储结构的定义、实现、输出、遍历。(未完待续).. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstring&gt;using namespace std;#define MAX_VERTEX_NUM 20 //最大顶点数const int infinity = INT_MAX;//无穷大struct ArcCell&#123; int adj;//对无权图用1,0表示是否相邻，对带权图为权值类型 char *info;//该弧的相关信息&#125;;struct MGraph &#123; string vexs[MAX_VERTEX_NUM];//顶点表 ArcCell arcs[MAX_VERTEX_NUM][MAX_VERTEX_NUM];//邻接矩阵，即边表 int vexnum;//顶点数 int arcnum;//边数 int kind;//邻接矩阵存储的图的种类&#125;;class Graph &#123; //图的数组存储表示private: MGraph mgraph; bool visited[MAX_VERTEX_NUM] = &#123; 0 &#125;;public: int LocateVex(string u);//图存在，图中存在顶点u则返回顶点在图中的位置 bool CreateDG();//构造有向图 bool CreateUDG();//构造无向图 bool CreateDN();//构造有向网 bool CreateUDN();//构造无向网 void DisPlay();//输出邻接矩阵 void DFSTraverse(int v);//深度优先遍历 void BFSTraverse(int v);//广度优先遍历 void clearVis();//清空访问数组&#125;;int Graph::LocateVex(string u) &#123; for (int i = 0; i &lt; MAX_VERTEX_NUM; i++) &#123; if (u == mgraph.vexs[i]) return i; &#125; return -1;&#125;//构造有向图bool Graph::CreateDG() &#123; int i, j; string v1, v2; cout &lt;&lt; "请输入有向图的顶点个数，边的个数："; cin &gt;&gt; mgraph.vexnum &gt;&gt; mgraph.arcnum; cout &lt;&lt; "请输入各个顶点："; for (i = 0; i &lt; mgraph.vexnum; i++) cin &gt;&gt; mgraph.vexs[i];//构造顶点向量 for (i = 0; i &lt; mgraph.vexnum; i++) &#123; for (j = 0; j &lt; mgraph.vexnum; j++) &#123; mgraph.arcs[i][j].adj = 0; mgraph.arcs[i][j].info = false; &#125; &#125; for (i = 0; i &lt; mgraph.arcnum; i++) &#123;//构造邻接矩阵 cout &lt;&lt; "请输入一条边的起点与终点："; cin &gt;&gt; v1 &gt;&gt; v2; int m = LocateVex(v1); int n = LocateVex(v2); mgraph.arcs[m][n].adj = 1; &#125; mgraph.kind = 1; return true;&#125;//构造无向图bool Graph::CreateUDG() &#123; int i, j; string v1, v2; cout &lt;&lt; "请输入无向图的顶点个数，边的个数："; cin &gt;&gt; mgraph.vexnum &gt;&gt; mgraph.arcnum; cout &lt;&lt; "请输入各个顶点："; for (i = 0; i &lt; mgraph.vexnum; i++) cin &gt;&gt; mgraph.vexs[i];//构造顶点向量 for (i = 0; i &lt; mgraph.vexnum; i++) &#123; for (j = 0; j &lt; mgraph.vexnum; j++) &#123; mgraph.arcs[i][j].adj = 0; mgraph.arcs[i][j].info = false; &#125; &#125; for (i = 0; i &lt; mgraph.arcnum; i++) &#123;//构造邻接矩阵 cout &lt;&lt; "请输入一条边依附的两个顶点："; cin &gt;&gt; v1 &gt;&gt; v2; int m = LocateVex(v1); int n = LocateVex(v2); mgraph.arcs[m][n].adj = 1; mgraph.arcs[n][m].adj = 1; &#125; mgraph.kind = 2; return true;&#125;//构造有向网bool Graph::CreateDN() &#123; int i, j; string v1, v2; cout &lt;&lt; "请输入有向网的顶点个数，边的个数："; cin &gt;&gt; mgraph.vexnum &gt;&gt; mgraph.arcnum; cout &lt;&lt; "请输入各个顶点："; for (i = 0; i &lt; mgraph.vexnum; i++) cin &gt;&gt; mgraph.vexs[i];//构造顶点向量 for (i = 0; i &lt; mgraph.vexnum; i++) &#123; for (j = 0; j &lt; mgraph.vexnum; j++) &#123; mgraph.arcs[i][j].adj = 0; mgraph.arcs[i][j].info = false; &#125; &#125; for (i = 0; i &lt; mgraph.arcnum; i++) &#123;//构造邻接矩阵 cout &lt;&lt; "请输入一条边的起点与终点："; cin &gt;&gt; v1 &gt;&gt; v2; int m = LocateVex(v1); int n = LocateVex(v2); cout &lt;&lt; "请输入该边的权值："; cin &gt;&gt; mgraph.arcs[m][n].adj; &#125; mgraph.kind = 3; return true;&#125;//构造无向网bool Graph::CreateUDN() &#123; int i, j; string v1, v2; cout &lt;&lt; "请输入无向网的顶点个数，边的个数："; cin &gt;&gt; mgraph.vexnum &gt;&gt; mgraph.arcnum; cout &lt;&lt; "请输入各个顶点："; for (i = 0; i &lt; mgraph.vexnum; i++) cin &gt;&gt; mgraph.vexs[i];//构造顶点向量 for (i = 0; i &lt; mgraph.vexnum; i++) &#123; for (j = 0; j &lt; mgraph.vexnum; j++) &#123; mgraph.arcs[i][j].adj = 0; mgraph.arcs[i][j].info = false; &#125; &#125; for (i = 0; i &lt; mgraph.arcnum; i++) &#123;//构造邻接矩阵 cout &lt;&lt; "请输入一条边依附的两个顶点："; cin &gt;&gt; v1 &gt;&gt; v2; int m = LocateVex(v1); int n = LocateVex(v2); cout &lt;&lt; "请输入该边的权值："; cin &gt;&gt; mgraph.arcs[m][n].adj; mgraph.arcs[n][m].adj = mgraph.arcs[m][n].adj; &#125; mgraph.kind = 4; return true;&#125;//输出邻接矩阵void Graph::DisPlay() &#123; cout &lt;&lt; "图的邻接矩阵为：" &lt;&lt; endl; for (int i = 0; i &lt; mgraph.vexnum; i++) &#123; for (int j = 0; j &lt; mgraph.vexnum; j++) &#123; cout &lt;&lt; mgraph.arcs[i][j].adj &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125;&#125;void Graph::DFSTraverse(int v) &#123; cout &lt;&lt; mgraph.vexs[v] &lt;&lt; " "; visited[v] = 1; for (int j = 0; j &lt; mgraph.vexnum; j++) &#123; if (mgraph.arcs[v][j].adj != 0 &amp;&amp; visited[j] == 0) DFSTraverse(j); &#125;&#125;void Graph::BFSTraverse(int v) &#123; int front = -1, rear = -1;//初始化队列，假设队列采用顺序存储且不会发生溢出 int Q[MAX_VERTEX_NUM]; cout &lt;&lt; mgraph.vexs[v] &lt;&lt; " "; visited[v] = 1; Q[++rear] = v;//被访问顶点入队 while (front != rear) &#123; v = Q[++front];//将队头元素出队并送到v中 for (int j = 0; j &lt; mgraph.vexnum; j++) &#123; if (mgraph.arcs[v][j].adj != 0 &amp;&amp; visited[j] == 0) &#123; cout &lt;&lt; mgraph.vexs[j] &lt;&lt; " "; visited[j] = 1; Q[++rear] = j; &#125; &#125; &#125;&#125;void Graph::clearVis() &#123; memset(visited, 0, sizeof(visited));&#125;int main() &#123; Graph GA;//有向图 GA.CreateDG(); GA.DisPlay(); cout &lt;&lt; "DFS:"; GA.DFSTraverse(0); GA.clearVis(); cout &lt;&lt; endl &lt;&lt; "BFS:"; GA.BFSTraverse(0); cout &lt;&lt; endl; Graph GB;//无向图 GB.CreateUDG(); GB.DisPlay(); cout &lt;&lt; "DFS:"; GB.DFSTraverse(0); GB.clearVis(); cout &lt;&lt; endl &lt;&lt; "BFS:"; GB.BFSTraverse(0); cout &lt;&lt; endl; Graph GC;//有向网 GC.CreateDN(); GC.DisPlay(); cout &lt;&lt; "DFS:"; GC.DFSTraverse(0); GC.clearVis(); cout &lt;&lt; endl &lt;&lt; "BFS:"; GC.BFSTraverse(0); cout &lt;&lt; endl; Graph GD;//无向网 GD.CreateUDN(); GD.DisPlay(); cout &lt;&lt; "DFS:"; GD.DFSTraverse(0); GD.clearVis(); cout &lt;&lt; endl &lt;&lt; "BFS:"; GD.BFSTraverse(0); cout &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>Data Structure</category>
        <category>Graph</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Poj3903 Stock Exchange]]></title>
    <url>%2F2018%2F12%2F17%2FPoj3903%2F</url>
    <content type="text"><![CDATA[DescriptionThe world financial crisis is quite a subject. Some people are more relaxed while others are quite anxious. John is one of them. He is very concerned about the evolution of the stock exchange. He follows stock prices every day looking for rising trends. Given a sequence of numbers p1, p2,…,pn representing stock prices, a rising trend is a subsequence pi1 &lt; pi2 &lt; … &lt; pik, with i1 &lt; i2 &lt; … &lt; ik. John’s problem is to find very quickly the longest rising trend. InputEach data set in the file stands for a particular set of stock prices. A data set starts with the length L (L ≤ 100000) of the sequence of numbers, followed by the numbers (a number fits a long integer). White spaces can occur freely in the input. The input data are correct and terminate with an end of file. OutputThe program prints the length of the longest rising trend. For each set of data the program prints the result to the standard output from the beginning of a line. Sample Input1234566 5 2 1 4 5 3 3 1 1 1 4 4 3 2 1 Sample Output1233 1 1 Analysis有一个长为n的数列a0,a1,…,an-1.求出最长上升子序列的长度，即对于任意的i]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Dynamic Programming</category>
        <category>Linear Dynamic Programming</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Huffman Tree]]></title>
    <url>%2F2018%2F12%2F13%2F%E9%9C%8D%E5%A4%AB%E6%9B%BC%E6%A0%91(Huffman%20Tree)%2F</url>
    <content type="text"><![CDATA[霍夫曼树的定义、实现及霍夫曼编码的求解与输出。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;using namespace std;struct HTNode &#123; int weight;//权值 int parent;//指向父结点的指针域 int lchild;//左指针域 int rchild;//右指针域&#125;;class huffman_BT &#123;private: HTNode *bt; char **hc; int nn;public: void select(HTNode *p, int k, int *i, int *j); void creat_hufm_BT(); int HuffmanCoding(); void HuffmanDisplay();&#125;;//在前k-1个结点中选择权值最小的两个结点i和jvoid huffman_BT::select(HTNode *p, int k, int *i, int *j) &#123; int w, n = 0; while (n &lt; k &amp;&amp; (p + n)-&gt;parent != -1) n++;//寻找指向父结点指针为空的起始结点 w = (p + n)-&gt;weight; *i = n; while (n &lt; k) &#123; if ((((p + n)-&gt;weight) &lt; w) &amp;&amp; ((p + n)-&gt;parent == -1)) *i = n, w = (p + n)-&gt;weight; n++; &#125; n = 0; while ((n &lt; k) &amp;&amp; ((p + n)-&gt;parent != -1) || (n == (*i))) n++; w = (p + n)-&gt;weight; *j = n; while (n &lt; k) &#123; if (((p + n)-&gt;weight &lt; w) &amp;&amp; (n != (*i)) &amp;&amp; ((p + n)-&gt;parent == -1)) &#123; *j = n; w = (p + n)-&gt;weight; &#125; n++; &#125; if ((*i) &lt; (*j)) n = (*i), *i = *j, *j = n;&#125;void huffman_BT::creat_hufm_BT() &#123; HTNode *p; int k, i, j, m; cout &lt;&lt; "请输入结点的个数："; cin &gt;&gt; nn; m = nn * 2 - 1; bt = new HTNode[m]; p = bt; for (i = 0; i &lt; m; i++) &#123; p[i].weight = 0; p[i].parent = -1; p[i].lchild = -1; p[i].rchild = -1; &#125; cout &lt;&lt; "请依次输入权值：" &lt;&lt; endl; for (i = 0; i &lt; nn; i++) &#123; cout &lt;&lt; "请输入第" &lt;&lt; i + 1 &lt;&lt; "个权值："; cin &gt;&gt; p[i].weight; &#125; for (k = nn; k &lt; m; k++) &#123; select(p, k, &amp;i, &amp;j); (p + i)-&gt;parent = k; (p + j)-&gt;parent = k; (p + k)-&gt;lchild = i; (p + k)-&gt;rchild = j; (p + k)-&gt;weight = (p + i)-&gt;weight + (p + j)-&gt;weight; &#125;&#125;//从叶子到根逆向求每个字符的霍夫曼编码int huffman_BT::HuffmanCoding() &#123; char *cd = new char[nn]; int start, c, f; hc = new char*[nn]; cd[nn - 1] = '\0'; for (int i = 0; i &lt; nn; i++) &#123; start = nn - 1; for (c = i, f = bt[i].parent; f != -1; c = f, f = bt[f].parent) &#123; if (bt[f].lchild == c) cd[--start] = '0'; else cd[--start] = '1'; &#125; hc[i] = new char[nn - start]; strcpy(hc[i], &amp;cd[start]); &#125; return 1;&#125;//霍夫曼编码信息输出void huffman_BT::HuffmanDisplay() &#123; HTNode *p; int k; p = bt; cout &lt;&lt; "k" &lt;&lt; setw(7) &lt;&lt; "weight" &lt;&lt; setw(7) &lt;&lt; "parent" &lt;&lt; setw(7) &lt;&lt; "lchild" &lt;&lt; setw(7) &lt;&lt; "rchild" &lt;&lt; endl; for (k = 0; k &lt; 2 * nn - 1; k++) &#123; cout &lt;&lt; k &lt;&lt; setw(7) &lt;&lt; (p + k)-&gt;weight &lt;&lt; setw(7) &lt;&lt; (p + k)-&gt;parent &lt;&lt; setw(7) &lt;&lt; (p + k)-&gt;lchild &lt;&lt; setw(7) &lt;&lt; (p + k)-&gt;rchild &lt;&lt; endl; &#125; cout &lt;&lt; "霍夫曼编码为：" &lt;&lt; endl; for (k = 0; k &lt; nn; k++) &#123; cout &lt;&lt; char('A' + k) &lt;&lt; "(权值：" &lt;&lt; p[k].weight &lt;&lt; "):" &lt;&lt; hc[k] &lt;&lt; endl; &#125;&#125;int main() &#123; huffman_BT hbt; hbt.creat_hufm_BT(); hbt.HuffmanCoding(); hbt.HuffmanDisplay(); return 0;&#125;]]></content>
      <categories>
        <category>Data Structure</category>
        <category>Binary Tree</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Poj1458 Common Subsequence]]></title>
    <url>%2F2018%2F12%2F12%2FPoj1458%2F</url>
    <content type="text"><![CDATA[DescriptionA subsequence of a given sequence is the given sequence with some elements (possible none) left out. Given a sequence X = &lt; x1, x2, …, xm &gt; another sequence Z = &lt; z1, z2, …, zk &gt; is a subsequence of X if there exists a strictly increasing sequence &lt; i1, i2, …, ik &gt; of indices of X such that for all j = 1,2,…,k, xij = zj. For example, Z = &lt; a, b, f, c &gt; is a subsequence of X = &lt; a, b, c, f, b, c &gt; with index sequence &lt; 1, 2, 4, 6 &gt;. Given two sequences X and Y the problem is to find the length of the maximum-length common subsequence of X and Y. InputThe program input is from the std input. Each data set in the input contains two strings representing the given sequences. The sequences are separated by any number of white spaces. The input data are correct. OutputFor each set of data the program prints on the standard output the length of the maximum-length common subsequence from the beginning of a separate line. Sample Input123abcfbc abfcabprogramming contest abcd mnp Sample Output123420 Analysis给定两个字符串，求出这两个字符串最长的公共子序列(LCS,Longest Common Subsequence)的长度。 用s1s2……sn和t1t2……tm表示两字符串，dp[i][j]表示s1……si和t1……tj对应的LCS的长度，由此，s1……si+1和t1……tj+1对应的公共子序列可能是 ​ 当si+1=tj+1时，在s1……si和t1……tj的公共子序列末尾追加上si+1 ​ s1……si和t1……tj+1的公共子列 ​ s1……si+1和t1……tj的公共子列 三者中的某一个，所以有如下递推式成立 dp[i][j]=\left\{\begin{array}{cc} dp[i-1][j-1]+1, & s_i=t_j\\ max(dp[i][j-1],dp[i-1][j]), & other\ \end{array}\right.Code12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;int n, m;int dp[1000 + 5][1000 + 5];char s1[1000 + 5];char s2[1000 + 5];int main()&#123; while (scanf("%s%s", s1, s2) != EOF) &#123; n = strlen(s1); m = strlen(s2); memset(dp, 0, sizeof(dp)); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; if (s1[i - 1] == s2[j - 1]) &#123; dp[i][j] = dp[i - 1][j - 1] + 1; &#125; else &#123; dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); &#125; &#125; &#125; cout &lt;&lt; dp[n][m] &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Dynamic Programming</category>
        <category>Linear Dynamic Programming</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Binary Tree]]></title>
    <url>%2F2018%2F12%2F06%2F%E4%BA%8C%E5%8F%89%E6%A0%91(Binary%20Tree)%2F</url>
    <content type="text"><![CDATA[二叉树的定义、实现、遍历、输出、应用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;queue&gt;using namespace std;struct BiTNode &#123; int data; BiTNode *lchild; BiTNode *rchild;&#125;;class BinaryTree &#123;private: BiTNode *bt; int RCreate(BiTNode *p, int k, int end);public: void CreateBiTree(int end); BinaryTree() &#123; bt = NULL; &#125; void Release(BiTNode *root); ~BinaryTree(); int PreTraverse(BiTNode *p); int InTraverse(BiTNode *p); int PostTraverse(BiTNode *p); void PreOrderTraverse(); void InOrderTraverse(); void PostOrderTraverse(); void LevelOrderTraverse(); void LeafCount(); void BiTreeDepth(); BiTNode *GetTreeNode(int item, BiTNode *lptr, BiTNode *rptr); BiTNode *CopyTree(BiTNode *p); int CompareTree(BiTNode *t1, BiTNode *t2); BiTNode *GetRoot(); void BiTreeDisplay(BiTNode *bt, int level = 1);&#125;;//创建二叉树递归函数int BinaryTree::RCreate(BiTNode * p, int k, int end) &#123; BiTNode *q; int e; cin &gt;&gt; e; if (e != end) &#123; q = new BiTNode; q-&gt;data = e; q-&gt;lchild = NULL; q-&gt;rchild = NULL; if (k == 1) p-&gt;lchild = q; if (k == 2) p-&gt;rchild = q; RCreate(q, 1, end); RCreate(q, 2, end); &#125; return 0;&#125;//按先序序列创建二叉树void BinaryTree::CreateBiTree(int end) &#123; cout &lt;&lt; "请按先序序列的顺序输入二叉树，0为空指针域标志：" &lt;&lt; endl; BiTNode *p; int e; cin &gt;&gt; e; if (e == end) return; p = new BiTNode; if (!p) &#123; cout &lt;&lt; "申请内存失败！" &lt;&lt; endl; exit(-1); &#125; p-&gt;data = e; p-&gt;lchild = NULL; p-&gt;rchild = NULL; bt = p; RCreate(p, 1, end); RCreate(p, 2, end);&#125;//先序遍历递归函数int BinaryTree::PreTraverse(BiTNode *p) &#123; if (p != NULL) &#123; cout &lt;&lt; p-&gt;data &lt;&lt; ' '; PreTraverse(p-&gt;lchild); PreTraverse(p-&gt;rchild); &#125; return 0;&#125;//中序遍历递归函数int BinaryTree::InTraverse(BiTNode *p) &#123; if (p != NULL) &#123; InTraverse(p-&gt;lchild); cout &lt;&lt; p-&gt;data &lt;&lt; ' '; InTraverse(p-&gt;rchild); &#125; return 0;&#125;//后续遍历递归函数int BinaryTree::PostTraverse(BiTNode * p) &#123; if (p != NULL) &#123; PostTraverse(p-&gt;lchild); PostTraverse(p-&gt;rchild); cout &lt;&lt; p-&gt;data &lt;&lt; ' '; &#125; return 0;&#125;//销毁二叉树递归函数void BinaryTree::Release(BiTNode *root) &#123; if (root != NULL) &#123; Release(root-&gt;lchild); Release(root-&gt;rchild); delete root; &#125;&#125;//析构函数BinaryTree::~BinaryTree() &#123; Release(bt);&#125;//非递归先序遍历二叉树void BinaryTree::PreOrderTraverse() &#123; cout &lt;&lt; "先序（非递归）遍历二叉树："; BiTNode *p = bt; stack&lt;BiTNode&gt; s; while (p || !s.empty()) &#123; if (p) &#123; cout &lt;&lt; p-&gt;data &lt;&lt; ' '; s.push(*p); p = p-&gt;lchild; &#125; else &#123; p = new BiTNode; *p = s.top(); s.pop(); p = p-&gt;rchild; &#125; &#125; cout &lt;&lt; endl;&#125;//非递归中序遍历二叉树void BinaryTree::InOrderTraverse() &#123; cout &lt;&lt; "中序（非递归）遍历二叉树："; BiTNode *p = bt; stack&lt;BiTNode&gt; s; while (p || !s.empty()) &#123; if (p) &#123; s.push(*p); p = p-&gt;lchild; &#125; else &#123; p = new BiTNode; *p = s.top(); s.pop(); cout &lt;&lt; p-&gt;data &lt;&lt; ' '; p = p-&gt;rchild; &#125; &#125; cout &lt;&lt; endl;&#125;//非递归后序遍历结点类型struct BiTNode1 &#123; BiTNode *bt; int tag;&#125;;//非递归后序遍历二叉树void BinaryTree::PostOrderTraverse() &#123; cout &lt;&lt; "后序（非递归）遍历二叉树："; BiTNode *p = bt; stack&lt;BiTNode1&gt; s; BiTNode1 *temp; while (p || !s.empty()) &#123; if (p) &#123; BiTNode1 *t = new BiTNode1; t-&gt;bt = p; t-&gt;tag = 1; s.push(*t); p = p-&gt;lchild; &#125; else &#123; temp = new BiTNode1; *temp = s.top(); s.pop(); if (temp-&gt;tag == 1) &#123; temp-&gt;tag = 2; s.push(*temp); p = new BiTNode; p = temp-&gt;bt-&gt;rchild; &#125; else &#123; cout &lt;&lt; temp-&gt;bt-&gt;data &lt;&lt; ' '; p = NULL; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;//层次遍历二叉树void BinaryTree::LevelOrderTraverse() &#123; cout &lt;&lt; "层次遍历二叉树："; queue&lt;BiTNode&gt; q; BiTNode *t; if (bt) &#123; q.push(*bt); while (!q.empty()) &#123; t = new BiTNode; *t = q.front(); q.pop(); if (t) cout &lt;&lt; t-&gt;data &lt;&lt; ' '; if (t-&gt;lchild) q.push(*t-&gt;lchild); if (t-&gt;rchild) q.push(*t-&gt;rchild); &#125; &#125; cout &lt;&lt; endl;&#125;//计算叶子的个数递归函数void Leaf(BiTNode *p, int &amp;count) &#123; if (p) &#123; Leaf(p-&gt;lchild, count); Leaf(p-&gt;rchild, count); if (p-&gt;lchild == NULL &amp;&amp; p-&gt;rchild == NULL) count++; &#125;&#125;//后序遍历计算叶子的个数void BinaryTree::LeafCount() &#123; int count = 0; Leaf(bt, count); cout &lt;&lt; "叶子的个数为" &lt;&lt; count &lt;&lt; endl;&#125;//计算深度递归函数void Depth(BiTNode *p, int level, int &amp;depth) &#123; if (p-&gt;lchild) Depth(p-&gt;lchild, level + 1, depth); if (p-&gt;rchild) Depth(p-&gt;rchild, level + 1, depth); if (level &gt; depth) depth = level;&#125;//后序遍历计算深度void BinaryTree::BiTreeDepth() &#123; int depth = 0; if (bt) &#123; Depth(bt, 1, depth); &#125; cout &lt;&lt; "二叉树的深度为" &lt;&lt; depth &lt;&lt; endl;&#125;//获取二叉树的一个结点BiTNode *BinaryTree::GetTreeNode(int item, BiTNode * lptr, BiTNode * rptr) &#123; BiTNode *p = new BiTNode; p-&gt;data = item; p-&gt;lchild = lptr; p-&gt;rchild = rptr; return p;&#125;//先序遍历复制一棵二叉树BiTNode *BinaryTree::CopyTree(BiTNode *p) &#123; BiTNode *newlptr, *newrptr; if (p == NULL) return NULL; if (p-&gt;lchild) newlptr = CopyTree(p-&gt;lchild); else newlptr = NULL; if (p-&gt;rchild) newrptr = CopyTree(p-&gt;rchild); else newrptr = NULL; bt = GetTreeNode(p-&gt;data, newlptr, newrptr);&#125;//先序遍历判断两棵二叉树是否相等int BinaryTree::CompareTree(BiTNode * t1, BiTNode * t2) &#123; if (t1 == NULL &amp;&amp; t2 == NULL) return 1; else if (t1-&gt;data == t2-&gt;data&amp;&amp;CompareTree(t1-&gt;lchild, t2-&gt;lchild) &amp;&amp; CompareTree(t1-&gt;rchild, t2-&gt;rchild)) return 1; else return 0;&#125;//获取根结点BiTNode* BinaryTree::GetRoot() &#123; if (bt != NULL) return bt; return NULL;&#125;//反中序递归横向树状显示一棵二叉树void BinaryTree::BiTreeDisplay(BiTNode * bt, int level) &#123; if (bt) &#123; BiTreeDisplay(bt-&gt;rchild, level + 1); for (int i = 0; i &lt; level; i++) cout &lt;&lt; " "; cout &lt;&lt; bt-&gt;data &lt;&lt; endl; BiTreeDisplay(bt-&gt;lchild, level + 1); &#125;&#125;int main() &#123; BinaryTree bit; BinaryTree bit1; while (1) &#123; bit.CreateBiTree(0); bit.BiTreeDisplay(bit.GetRoot(),0); cout &lt;&lt; "先序（递归）遍历二叉树："; bit.PreTraverse(bit.GetRoot()); cout &lt;&lt; endl; cout &lt;&lt; "中序（递归）遍历二叉树："; bit.InTraverse(bit.GetRoot()); cout &lt;&lt; endl; cout &lt;&lt; "后序（递归）遍历二叉树："; bit.PostTraverse(bit.GetRoot()); cout &lt;&lt; endl; bit.PreOrderTraverse(); bit.InOrderTraverse(); bit.PostOrderTraverse(); bit.LevelOrderTraverse(); bit.LeafCount(); bit.BiTreeDepth(); bit1.CopyTree(bit.GetRoot()); bit1.BiTreeDisplay(bit1.GetRoot(), 0); if (bit1.CompareTree(bit.GetRoot(), bit1.GetRoot())) cout &lt;&lt; "相等，拷贝成功" &lt;&lt; endl; cout &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Data Structure</category>
        <category>Binary Tree</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Poj1651 Multiplication Puzzle]]></title>
    <url>%2F2018%2F11%2F19%2FPoj1651%2F</url>
    <content type="text"><![CDATA[DescriptionThe multiplication puzzle is played with a row of cards, each containing a single positive integer. During the move player takes one card out of the row and scores the number of points equal to the product of the number on the card taken and the numbers on the cards on the left and on the right of it. It is not allowed to take out the first and the last card in the row. After the final move, only two cards are left in the row. The goal is to take cards in such order as to minimize the total number of scored points. For example, if cards in the row contain numbers 10 1 50 20 5, player might take a card with 1, then 20 and 50, scoring $10150 + 50205 + 10505 = 500+5000+2500 = 8000 $.If he would take the cards in the opposite order, i.e. 50, then 20, then 1, the score would be $15020 + 1205 + 1015 = 1000+100+50 = 1150$. InputThe first line of the input contains the number of cards $N (3 \leq N \leq 100)$. The second line contains N integers in the range from 1 to 100, separated by spaces. OutputOutput must contain a single integer - the minimal score. Sample Input12610 1 50 50 20 5 Sample Output13650 Analysis一列数字，每次从中取出一个数字（不能是第一个或最后一个），得分是这个数字与它前后两边数字的乘积，一直取到还剩下两个数字，求可以得到的最小的分数。 可以采用区间DP的做法，从最小的区间（3个数字）开始，逐步扩大区间，用dp数组存储每个区间可以得到的最小的分数，最后得到整个区间可以得到的最小的分数。 用dp[i][j]表示区间i-1到j可以获得的最小的分数，则递推式 $dp[i][j]=\min(dp[i][j],dp[i][k]+dp[k+1][j]+card[i-1]\times card[k]\times card[j])$;表示当最后一次取的是第k个时，k之前与k之后区间的最小得分与取第k个时它与该区间开头与结尾的分的乘积的和（因为左右区间都取过了），就是当前区间可以得到的最小得分。 Code12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int N;int card[105];int dp[105][105];int main()&#123; while (cin &gt;&gt; N) &#123; for (int i = 0; i &lt; N; i++) &#123; cin &gt;&gt; card[i]; &#125; memset(dp, 0, sizeof(dp)); for (int len = 1; len &lt; N; len++) &#123; int i, j, k; for (i = 1, j = len + 1; j &lt; N; i++, j++) &#123; int min = 9999999; for (k = i; k &lt; j; k++) &#123; int count = dp[i][k] + dp[k + 1][j] + card[i - 1] * card[k] * card[j]; if (count &lt; min) min = count; dp[i][j] = min; &#125; &#125; &#125; cout &lt;&lt; dp[1][N - 1] &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Dynamic Programming</category>
        <category>Interval Dynamic Programming</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Poj3624 Charm Bracelet]]></title>
    <url>%2F2018%2F11%2F15%2FPoj3624%2F</url>
    <content type="text"><![CDATA[DescriptionBessie has gone to the mall’s jewelry store and spies a charm bracelet. Of course, she’d like to fill it with the best charms possible from the N (1 ≤ N ≤ 3,402) available charms. Each charm i in the supplied list has a weight Wi (1 ≤ Wi ≤ 400), a ‘desirability’ factor Di (1 ≤ Di ≤ 100), and can be used at most once. Bessie can only support a charm bracelet whose weight is no more than M (1 ≤ M ≤ 12,880).Given that weight limit as a constraint and a list of the charms with their weights and desirability rating, deduce the maximum possible sum of ratings. Input* Line 1: Two space-separated integers: N and M Lines 2..N+1: Line i+1 describes charm i with two space-separated integers: Wi and Di* Output* Line 1: A single integer that is the greatest sum of charm desirabilities that can be achieved given the weight constraints Sample Input123454 61 42 63 122 7 Sample Output123 AnalysisN 个物品每个物品有价值d[i]，重量w[i]， 给定背包最大承重M，求背包能够装载的最大价值。每个物品只有放入背包和不放入背包两种选择。这是典型的0-1背包问题。 直接套用模板即可。 Code123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;int N, M;int dp[12800 + 1];int W[3402 + 1];int D[3402 + 1];int main()&#123; while (cin &gt;&gt; N &gt;&gt; M) &#123; memset(dp, 0, sizeof(dp)); memset(W, 0, sizeof(W)); memset(D, 0, sizeof(D)); for (int i = 0; i &lt; N; i++) &#123; cin &gt;&gt; W[i] &gt;&gt; D[i]; for (int j = M; j &gt;= W[i]; j--) &#123; dp[j] = max(dp[j], dp[j - W[i]] + D[i]); &#125; &#125; cout &lt;&lt; dp[M] &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Dynamic Programming</category>
        <category>Knapsack Problem</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Poj1328 Radar Installation]]></title>
    <url>%2F2018%2F11%2F14%2FPoj1328%2F</url>
    <content type="text"><![CDATA[DescriptionAssume the coasting is an infinite straight line. Land is in one side of coasting, sea in the other. Each small island is a point locating in the sea side. And any radar installation, locating on the coasting, can only cover d distance, so an island in the sea can be covered by a radius installation, if the distance between them is at most d. We use Cartesian coordinate system, defining the coasting is the x-axis. The sea side is above x-axis, and the land side below. Given the position of each island in the sea, and given the distance of the coverage of the radar installation, your task is to write a program to find the minimal number of radar installations to cover all the islands. Note that the position of an island is represented by its x-y coordinates. ​ Figure A Sample Input of Radar Installations InputThe input consists of several test cases. The first line of each case contains two integers n (1&lt;=n&lt;=1000) and d, where n is the number of islands in the sea and d is the distance of coverage of the radar installation. This is followed by n lines each containing two integers representing the coordinate of the position of each island. Then a blank line follows to separate the cases. The input is terminated by a line containing pair of zeros OutputFor each test case output one line consisting of the test case number followed by the minimal number of radar installations needed. “-1” installation means no solution for that case. Sample Input1234567893 21 2-3 12 11 20 20 0 Sample Output12Case 1: 2Case 2: 1 Analysis在直线上放置点，使直线上方的所有点都位于直线上点半径d范围内，求最少放置多少个点。 可以换一种方法思考，如果上方的点在直线上点的d范围内，那么直线上点也一定在上方点d范围内，那么以上方点为圆心，d为半径作圆，与直线相交得到一条弦，直线上点必须放置在这条弦的区间范围内，这样就可以采用贪心思想，从左往右将有重叠部分的区间合并，直到无法再合并时，放置的点数再加一，最后得到最少解。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;using namespace std;int n;double d;struct p&#123; double x, y;&#125;;p point[1005];p que[1005];bool operator &lt; (p a, p b)&#123; return a.x &lt; b.x;&#125;int main()&#123; int Case = 1; while (cin &gt;&gt; n &gt;&gt; d) &#123; memset(point, 0, sizeof(point)); memset(que, -10000, sizeof(que)); if (n == 0) break; bool flag = 1; int count = 0; int ans = 1; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; point[i].x &gt;&gt; point[i].y; if (point[i].y &gt; d) flag = 0; &#125; sort(point, point + n); for (int i = 0; i &lt; n; i++) &#123; double dx = sqrt(d*d - point[i].y*point[i].y); que[i].x = point[i].x - dx; que[i].y = point[i].x + dx; &#125; for (int i = 1; i &lt; n ; i++) &#123; if (que[i - 1].y &lt; que[i].x) &#123; ans++; &#125; else if (que[i - 1].y &gt;= que[i].x&amp;&amp;que[i - 1].y &lt;= que[i].y) &#123; que[i].y = que[i - 1].y; &#125; else if (que[i - 1].x &gt; que[i].x&amp;&amp;que[i - 1].y &lt; que[i].y) &#123; que[i].x = que[i - 1].x; que[i].y = que[i - 1].y; &#125; &#125; if (flag == 0 || d &lt;= 0) &#123; ans = -1; &#125; cout &lt;&lt; "Case " &lt;&lt; Case &lt;&lt; ": " &lt;&lt; ans &lt;&lt; endl; Case++; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Greedy</category>
      </categories>
      <tags>
        <tag>POJ</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Poj3253 Fence Repair]]></title>
    <url>%2F2018%2F11%2F13%2FPoj3253%2F</url>
    <content type="text"><![CDATA[DescriptionFarmer John wants to repair a small length of the fence around the pasture. He measures the fence and finds that he needs N (1 ≤ N ≤ 20,000) planks of wood, each having some integer length Li (1 ≤ Li ≤ 50,000) units. He then purchases a single long board just long enough to saw into the N planks (i.e., whose length is the sum of the lengths Li). FJ is ignoring the “kerf”, the extra length lost to sawdust when a sawcut is made; you should ignore it, too.FJ sadly realizes that he doesn’t own a saw with which to cut the wood, so he mosies over to Farmer Don’s Farm with this long board and politely asks if he may borrow a saw.Farmer Don, a closet capitalist, doesn’t lend FJ a saw but instead offers to charge Farmer John for each of the N-1 cuts in the plank. The charge to cut a piece of wood is exactly equal to its length. Cutting a plank of length 21 costs 21 cents.Farmer Don then lets Farmer John decide the order and locations to cut the plank. Help Farmer John determine the minimum amount of money he can spend to create the N planks. FJ knows that he can cut the board in various different orders which will result in different charges since the resulting intermediate planks are of different lengths. InputLine 1: One integer N, the number of planks Lines 2..N+1: Each line contains a single integer describing the length of a needed plank OutputLine 1: One integer: the minimum amount of money he must spend to make N-1 cuts Sample Input12343858 Sample Output134 Analysis（以下方法来自《挑战程序设计竞赛.第2版》） 题目貌似很难入手，但是可以用略微奇特的贪心法来求解。 首先，切割的方法可以用如下二叉树来描述： 每一个叶子节点对应了切割出的一块块木板。叶子节点的深度（第一个节点为0）就对应了为了得到对应木板所需的切割次数，开销的合计就是各叶子节点的 ​ 木板的长度 X 节点的深度 的总和。例如，上图示例的全部开销就可以这样计算： ​ 3 X 2 + 4 X 2 + 5 X 2 + 1 X 3 + 2 X 3=33 于是，此时的最佳切割方法首先应该具有如下性质： ​ 最短的板与次短的板的节点应当是兄弟节点 对于最优解来讲，最短的板应当是深度最大的叶子节点之一。所以与这个叶子节点同一深度的兄弟节点一定存在，并且由于同样是最深的叶子节点，所以应该对应于次短的板。 不妨将Li按照大小顺序排列，那么最短的板就应该是L1而次短的则是L2。如果它们在二叉树中是兄弟节点，就意味着它们是从一块长度为(L1+L2)的板切割而来的。由于切割顺序是自由的，不妨当作是最后被切割。这样一来，在这次切割前就有 ​ (L1+L2),L3,L4,…,LN 这样的N-1块木板存在。与以上讨论的方式相同，递归地将这N-1块木板的问题求解，就可以求出整个问题的答案。这样实现的话，虽然复杂度是O(N^2)，对于题目的输入规模来说，已经足以在时间限制内通过了。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;int n, l[20005];int main()&#123; while (cin &gt;&gt; n) &#123; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; l[i]; &#125; ll ans = 0; //直到计算到木块为1块时停止 while (n &gt; 1) &#123; //求出最短的板mii1和次短的板mii2 int mii1 = 0, mii2 = 1; if (l[mii1] &gt; l[mii2]) swap(mii1, mii2); for (int i = 2; i &lt; n; i++) &#123; if (l[i] &lt; l[mii1]) &#123; mii2 = mii1; mii1 = i; &#125; else if (l[i] &lt; l[mii2]) &#123; mii2 = i; &#125; &#125; //将两块板拼合 int t = l[mii1] + l[mii2]; ans += t; //如果最短板mii1是n-1，因为n要减少，所以需要把它提前，防止下次循环时数据已经被丢弃 if (mii1 == n - 1) swap(mii1, mii2); l[mii1] = t; l[mii2] = l[n - 1]; n--; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Greedy</category>
      </categories>
      <tags>
        <tag>POJ</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Poj3069 Saruman's Army]]></title>
    <url>%2F2018%2F11%2F13%2FPoj3069%2F</url>
    <content type="text"><![CDATA[DescriptionSaruman the White must lead his army along a straight path from Isengard to Helm’s Deep. To keep track of his forces, Saruman distributes seeing stones, known as palantirs, among the troops. Each palantir has a maximum effective range of R units, and must be carried by some troop in the army (i.e., palantirs are not allowed to “free float” in mid-air). Help Saruman take control of Middle Earth by determining the minimum number of palantirs needed for Saruman to ensure that each of his minions is within R units of some palantir. InputThe input test file will contain multiple cases. Each test case begins with a single line containing an integer R, the maximum effective range of all palantirs (where 0 ≤ R ≤ 1000), and an integer n, the number of troops in Saruman’s army (where 1 ≤ n ≤ 1000). The next line contains n integers, indicating the positions x1, …, xn of each troop (where 0 ≤ xi ≤ 1000). The end-of-file is marked by a test case with R = n = −1. OutputFor each test case, print a single integer indicating the minimum number of palantirs needed. Sample Input123450 310 20 2010 770 30 1 7 15 20 50-1 -1 Sample Output1224 Analysis一条直线上有n个点，从n各点中选若干个加上标记，对于每一个点，距离其R以内的区域里必须有一个被标记的点，问至少有多少点需要加上标记。 根据贪心的思想，使用以下步骤： 从最左点开始，这个点右侧R距离以内的区域必须有一个被标记的点，那么就给距离其R以内的离它最远的点加上标记。 找到这个被标记点右侧R距离外最近的一个点。 将此点作为最左点，重复1、2，直到所有点都被覆盖。 Code123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int r, n; int x[10000]; while (cin &gt;&gt; r &gt;&gt; n) &#123; if (r == -1 &amp;&amp; n == -1) break; memset(x, 0, sizeof(x)); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; x[i]; &#125; sort(x, x + n); int i = 0, ans = 0; while (i &lt; n) &#123; int s = x[i++]; while (i &lt; n&amp;&amp;x[i] &lt;= s + r) i++; int p = x[i - 1]; while (i &lt; n&amp;&amp;x[i] &lt;= p + r) i++; ans++; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Greedy</category>
      </categories>
      <tags>
        <tag>POJ</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Poj3617 Best Cow Line]]></title>
    <url>%2F2018%2F11%2F08%2FPoj3617%2F</url>
    <content type="text"><![CDATA[DescriptionFJ is about to take his N (1 ≤ N ≤ 2,000) cows to the annual”Farmer of the Year” competition. In this contest every farmer arranges his cows in a line and herds them past the judges.The contest organizers adopted a new registration scheme this year: simply register the initial letter of every cow in the order they will appear (i.e., If FJ takes Bessie, Sylvia, and Dora in that order he just registers BSD). After the registration phase ends, every group is judged in increasing lexicographic order according to the string of the initials of the cows’ names.FJ is very busy this year and has to hurry back to his farm, so he wants to be judged as early as possible. He decides to rearrange his cows, who have already lined up, before registering them.FJ marks a location for a new line of the competing cows. He then proceeds to marshal the cows from the old line to the new one by repeatedly sending either the first or last cow in the (remainder of the) original line to the end of the new line. When he’s finished, FJ takes his cows for registration in this new order.Given the initial order of his cows, determine the least lexicographic string of initials he can make this way. Input* Line 1: A single integer: N Lines 2..N+1: Line i+1 contains a single initial (‘A’..’Z’) of the cow in the i*th position in the original line OutputThe least lexicographic string he can make. Every line (except perhaps the last one) contains the initials of 80 cows (‘A’..’Z’) in the new line. Sample Input12345676ACDBCB Sample Output1ABCBCD Analysis水题，每次从字符串的首部或尾部提取字母放入新串，使得新串最后的字典序最小。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;using namespace std;int main()&#123; int n; while (cin &gt;&gt; n) &#123; cin.get(); char s[10000] = &#123; 0 &#125;; char ch; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; ch; cin.get(); s[i] = ch; &#125; int a = 0, b = n - 1; int ans = 0; while (a &lt;= b) &#123; bool left = false; for (int i = 0; a + i &lt;= b; i++) &#123; if (s[a + i] &lt; s[b - i]) &#123; left = true; break; &#125; else if (s[a + i] &gt; s[b - i]) &#123; left = false; break; &#125; &#125; if (left) cout &lt;&lt; s[a++]; else cout &lt;&lt; s[b--]; ans += 1; if (ans == 80) &#123; cout &lt;&lt; endl; ans = 0; &#125; &#125; cout &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Greedy</category>
      </categories>
      <tags>
        <tag>POJ</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Poj3279 Fliptile]]></title>
    <url>%2F2018%2F11%2F07%2FPoj3279%2F</url>
    <content type="text"><![CDATA[DescriptionFarmer John knows that an intellectually satisfied cow is a happy cow who will give more milk. He has arranged a brainy activity for cows in which they manipulate an M × N grid (1 ≤ M ≤ 15; 1 ≤ N ≤ 15) of square tiles, each of which is colored black on one side and white on the other side.As one would guess, when a single white tile is flipped, it changes to black; when a single black tile is flipped, it changes to white. The cows are rewarded when they flip the tiles so that each tile has the white side face up. However, the cows have rather large hooves and when they try to flip a certain tile, they also flip all the adjacent tiles (tiles that share a full edge with the flipped tile). Since the flips are tiring, the cows want to minimize the number of flips they have to make.Help the cows determine the minimum number of flips required, and the locations to flip to achieve that minimum. If there are multiple ways to achieve the task with the minimum amount of flips, return the one with the least lexicographical ordering in the output when considered as a string. If the task is impossible, print one line with the word “IMPOSSIBLE”. InputLine 1: Two space-separated integers: M and N Lines 2..M+1: Line i+1 describes the colors (left to right) of row i of the grid with N space-separated integers which are 1 for black and 0 for white OutputLines 1..M: Each line contains N space-separated integers, each specifying how many times to flip that particular location. Sample Input123454 41 0 0 10 1 1 00 1 1 01 0 0 1 Sample Output12340 0 0 01 0 0 11 0 0 10 0 0 0 Analysis题意：一个m*n的方格，每格为1或0，每次可对一格进行翻转（0变为1或1变为0），则该格和其上下左右4格都会被翻转。问多少次翻转可以把所有格子全部变为0，如果无法全部变为0就输出”IMPOSSILBE”。 采用二进制搜索，假设有n列，先考虑第一行的情况，每格都有0或者1两种状态，那么n列就是2^n种状态，再考虑剩下的m-1行，每一行的翻转都必须使它的上一行全为0，这样才能进行下一行的翻转。于是，第一行的情况就确定了剩下所有行的情况。输出所有情况下翻转次数最少的那种情况，如果没有情况满足则输出IMPOSSIBLE。 用二进制形式来对应翻转的位置，二进制位为1则该位翻转，二进制位为0则该位不翻转，每次循环二进制右移一位以此进行下一位的操作。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int a[20][20];//存储输入的方格int b[20][20];//输入方格的拷贝，方便进行翻转int f[20][20];//存储翻转完成后的方格int ans[20][20];//存储应当输出的最小次数的方格int anum, fnum;//最小翻转次数，每种情况的翻转次数int m, n;void ex(int x, int y)//对方格b，x行y列进行一次翻转&#123; fnum++; f[x][y] = 1; b[x][y] = 1 - b[x][y]; b[x - 1][y] = 1 - b[x - 1][y]; b[x + 1][y] = 1 - b[x + 1][y]; b[x][y - 1] = 1 - b[x][y - 1]; b[x][y + 1] = 1 - b[x][y + 1];&#125;int main()&#123; cin &gt;&gt; m &gt;&gt; n; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; cin &gt;&gt; a[i][j]; &#125; &#125; int t = 1 &lt;&lt; n;//即2^n种情况 anum = 10000; for (int loop = 0; loop &lt; t; loop++) &#123; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; b[i][j] = a[i][j]; &#125; &#125; fnum = 0; int moven = loop; memset(f, 0, sizeof(f)); for (int j = 1; j &lt;= n; j++)//翻转第一行 &#123; if (moven &amp; 1) &#123; ex(1, j); &#125; moven = moven &gt;&gt; 1; &#125; for (int i = 2; i &lt;= m; i++)//翻转剩下的行 &#123; for (int j = 1; j &lt;= n; j++) &#123; if (b[i - 1][j]) ex(i, j); &#125; &#125; int j; for (j = 1; j &lt;= n; j++)//最后一行有1，不满足条件 &#123; if (b[m][j]) break; &#125; if (j == n + 1 &amp;&amp; fnum &lt; anum)//每次循环更新次数最小情况 &#123; anum = fnum; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; ans[i][j] = f[i][j]; &#125; &#125; &#125; &#125; if (anum == 10000) &#123; cout &lt;&lt; "IMPOSSIBLE" &lt;&lt; endl; &#125; else &#123; for (int i = 1; i &lt;= m; i++) &#123; cout &lt;&lt; ans[i][1]; for (int j = 2; j &lt;= n; j++) &#123; cout &lt;&lt; " " &lt;&lt; ans[i][j]; &#125; cout &lt;&lt; endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Search</category>
      </categories>
      <tags>
        <tag>POJ</tag>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Poj1852 Ants]]></title>
    <url>%2F2018%2F11%2F06%2FPoj1852%2F</url>
    <content type="text"><![CDATA[DescriptionAn army of ants walk on a horizontal pole of length l cm, each with a constant speed of 1 cm/s. When a walking ant reaches an end of the pole, it immediatelly falls off it. When two ants meet they turn back and start walking in opposite directions. We know the original positions of ants on the pole, unfortunately, we do not know the directions in which the ants are walking. Your task is to compute the earliest and the latest possible times needed for all ants to fall off the pole. InputThe first line of input contains one integer giving the number of cases that follow. The data for each case start with two integer numbers: the length of the pole (in cm) and n, the number of ants residing on the pole. These two numbers are followed by n integers giving the position of each ant on the pole as the distance measured from the left end of the pole, in no particular order. All input integers are not bigger than 1000000 and they are separated by whitespace. OutputFor each case of input, output two numbers separated by a single space. The first number is the earliest possible time when all ants fall off the pole (if the directions of their walks are chosen appropriately) and the second number is the latest possible such time. Sample Input12345210 32 6 7214 711 12 7 13 176 23 191 Sample Output124 838 207 Analysis两只蚂蚁相遇后掉头，但是蚂蚁之间并没有任何区别，可以看作蚂蚁保持原来的方向继续前进，那么找出离端点最近和最远的点即可，便是最快时间和最慢时间。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;using namespace std;int max(int m, int n)&#123; if (m &gt; n) return m; else return n;&#125;int min(int m, int n)&#123; if (m &gt; n) return n; else return m;&#125;int main()&#123; int t; cin &gt;&gt; t; while (t-- != 0) &#123; int L, n; cin &gt;&gt; L &gt;&gt; n; int x[100000]; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; x[i]; &#125; int minT = 0; for (int i = 0; i &lt; n; i++) &#123; minT = max(minT, min(x[i], L - x[i])); &#125; int maxT = 0; for (int i = 0; i &lt; n; i++) &#123; maxT = max(maxT, max(x[i], L - x[i])); &#125; cout &lt;&lt; minT &lt;&lt; " " &lt;&lt; maxT &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Others</category>
      </categories>
      <tags>
        <tag>POJ</tag>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Poj1276 Cash Machine]]></title>
    <url>%2F2018%2F10%2F04%2FPoj1276%2F</url>
    <content type="text"><![CDATA[DescriptionA Bank plans to install a machine for cash withdrawal. The machine is able to deliver appropriate @ bills for a requested cash amount. The machine uses exactly N distinct bill denominations, say Dk, k=1,N, and for each denomination Dk the machine has a supply of nk bills. For example, N=3, n1=10, D1=100, n2=4, D2=50, n3=5, D3=10 means the machine has a supply of 10 bills of @100 each, 4 bills of @50 each, and 5 bills of @10 each. Call cash the requested amount of cash the machine should deliver and write a program that computes the maximum amount of cash less than or equal to cash that can be effectively delivered according to the available bill supply of the machine. Notes:@ is the symbol of the currency delivered by the machine. For instance, @ may stand for dollar, euro, pound etc. InputThe program input is from standard input. Each data set in the input stands for a particular transaction and has the format: cash N n1 D1 n2 D2 … nN DN where 0 &lt;= cash &lt;= 100000 is the amount of cash requested, 0 &lt;=N &lt;= 10 is the number of bill denominations and 0 &lt;= nk &lt;= 1000 is the number of available bills for the Dk denomination, 1 &lt;= Dk &lt;= 1000, k=1,N. White spaces can occur freely between the numbers in the input. The input data are correct. OutputFor each set of data the program prints the result to the standard output on a separate line as shown in the examples below. Sample Input1234735 3 4 125 6 5 3 350633 4 500 30 6 100 1 5 0 1735 00 3 10 100 10 50 10 10 Sample Output123473563000 Analysis此题为多重背包，但和之前的多重背包题不同。这里从第一种币面值开始循环，每次记录当前币面值和数量搭配可以组成的情况，用dp[i]表示组成价值i时，当前币面值的货币还剩下多少张。循环完毕后换下一种币面值，并更新数量，如果前一种币面值已经组成了某个价值i,就把dp[i]，即剩下的张数替换为目前币面值的数量。这样循环结束后，小于等于呼叫的钱的第一种可以组成的价值dp[i]，即充分利用所有币面值且最后一种币面值数量仍有剩余时得到的价值，即为最大价值。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int n[10 + 2];int D[10 + 2];int dp[100000];int main()&#123; int cash; while (cin &gt;&gt; cash) &#123; int N; cin &gt;&gt; N; memset(dp, -1, sizeof(dp)); memset(n, 0, sizeof(n)); memset(D, 0, sizeof(D)); dp[0] = 0; for (int i = 0; i &lt; N; i++) &#123; cin &gt;&gt; n[i] &gt;&gt; D[i]; for (int j = 0; j &lt;= cash; j++) &#123; if (dp[j] &gt;= 0) dp[j] = n[i]; else if (j &lt; D[i] || dp[j - D[i]] &lt;= 0) &#123; dp[j] = -1; &#125; else dp[j] = dp[j - D[i]] - 1; &#125; &#125; for (int i = cash; i &gt;= 0; i--) &#123; if (dp[i] &gt;= 0) &#123; cout &lt;&lt; i &lt;&lt; endl; break; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Dynamic Programming</category>
        <category>Knapsack Problem</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hdu2082 找单词]]></title>
    <url>%2F2018%2F10%2F02%2FHdu2082%2F</url>
    <content type="text"><![CDATA[Description假设有x1个字母A， x2个字母B,….. x26个字母Z，同时假设字母A的价值为1，字母B的价值为2,….. 字母Z的价值为26。那么，对于给定的字母，可以找到多少价值&lt;=50的单词呢？单词的价值就是组成一个单词的所有字母的价值之和，比如，单词ACM的价值是1+3+14=18，单词HDU的价值是8+4+21=33。(组成的单词与排列顺序无关，比如ACM与CMA认为是同一个单词）。 Input输入首先是一个整数N，代表测试实例的个数。然后包括N行数据，每行包括26个&lt;=20的整数x1,x2,…..x26. Output对于每个测试实例，请输出能找到的总价值&lt;=50的单词数,每个实例的输出占一行。 Sample Input12321 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 09 2 6 2 10 2 2 5 6 1 0 2 7 0 2 2 7 5 10 6 10 2 10 6 1 9 Sample Output127379297 Analysis类似于HDU2079，是一道多重背包，不过价值是已经定下来的即1—26。给定字母的数量后，采用递推关系，用一维数组进行DP，把dp[n]，n&lt;=50的所有情况加起来即可。 用c[i]存储每个字母数量，从50价值开始向前更新，选择1到c[i]个字母，如果能加上且不超过50，价值i的情况就加上加上选择的字母的价值刚好满足i价值的情况，递推下来得到50之前所有可能的组合情况，再扫一遍全部加起来即可。 Code1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int v[26] = &#123; 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26 &#125;;int main()&#123; int n; cin &gt;&gt; n; while (n-- != 0) &#123; int dp[55]; memset(dp, 0, sizeof(dp)); dp[0] = 1; int count = 0; int c[26]; for (int i = 0; i &lt; 26; i++) &#123; cin &gt;&gt; c[i]; for (int j = 50; j &gt;= v[i]; j--) &#123; for (int k = 1; k &lt;= c[i]; k++) &#123; if (k*v[i] &lt;= j) dp[j] += dp[j - k * v[i]]; &#125; &#125; &#125; for (int i = 1; i &lt; 51; i++) &#123; count += dp[i]; &#125; cout &lt;&lt; count &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Dynamic Programming</category>
        <category>Knapsack Problem</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hdu2079 选课时间]]></title>
    <url>%2F2018%2F09%2F26%2FHdu2079%2F</url>
    <content type="text"><![CDATA[Description又到了选课的时间了，xhd看着选课表发呆，为了想让下一学期好过点，他想知道学n个学分共有多少组合。你来帮帮他吧。（xhd认为一样学分的课没区别） Input输入数据的第一行是一个数据T，表示有T组数据。每组数据的第一行是两个整数n(1 &lt;= n &lt;= 40)，k(1 &lt;= k &lt;= 8)。接着有k行，每行有两个整数a(1 &lt;= a &lt;= 8),b(1 &lt;= b &lt;= 10)，表示学分为a的课有b门。 Output对于每组输入数据，输出一个整数，表示学n个学分的组合数。 Sample Input1234567891011121322 21 22 140 81 12 23 24 25 86 97 68 8 Sample Output122445 Analysis一道多重背包题目，学分即物品价值，一门课数量即物品数量，采用递推关系，可以用一维数组来进行DP。 dp[n]的含义就是价值为n的时候有多少种情况。 从最终的学分向前更新，选择1到b门课，如果选择的课的学分能加上且不过界，i学分的情况就加上加上选择的课的学分刚好满足i学分的情况，这样递推下来得到n学分的组合。 Code1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;int main()&#123; int t, n, m, i, j, a, b, dp[55]; cin &gt;&gt; t; while (t--) &#123; cin &gt;&gt; n &gt;&gt; m; for (i = dp[0] = 1; i &lt; 55; i++) &#123; dp[i] = 0; &#125; while (m--) &#123; cin &gt;&gt; a &gt;&gt; b; for (i = n; i &gt;= a; i--) &#123; for (j = 1; j &lt;= b; j++) &#123; if (j*a &lt;= i) dp[i] += dp[i - j * a]; &#125; &#125; &#125; cout &lt;&lt; dp[n] &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Dynamic Programming</category>
        <category>Knapsack Problem</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hdu2084 数塔]]></title>
    <url>%2F2018%2F09%2F23%2FHdu2084%2F</url>
    <content type="text"><![CDATA[Description在讲述DP算法的时候，一个经典的例子就是数塔问题，它是这样描述的： 有如下所示的数塔，要求从顶层走到底层，若每一步只能走到相邻的结点，则经过的结点的数字之和最大是多少？ 已经告诉你了，这是个DP的题目，你能AC吗? Input输入数据首先包括一个整数C,表示测试实例的个数，每个测试实例的第一行是一个整数N(1 &lt;= N &lt;= 100)，表示数塔的高度，接下来用N行数字表示数塔，其中第i行有个i个整数，且所有的整数均在区间[0,99]内。 Output对于每个测试实例，输出可能得到的最大和，每个实例的输出占一行。 Sample Input12345671573 88 1 0 2 7 4 44 5 2 6 5 Sample Output130 AnalysisDP的裸题，思路是每个结点都存储走到当前结点经过的结点的数字所能组成的最大和，在最低层扫一遍进行比较，有些贪心的味道。处理好最左侧与最右侧的递推关系，中间的的递推式为 1dp[i][j] = to[i][j] + max(dp[i - 1][j - 1], dp[i - 1][j]); Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;int to[101][101];int dp[101][101];int main()&#123; int C; cin &gt;&gt; C; while (C-- != 0) &#123; int N; cin &gt;&gt; N; memset(to, 0, sizeof(to)); for (int i = 1; i &lt;= N; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; cin &gt;&gt; to[i][j]; &#125; &#125; memset(dp, 0, sizeof(dp)); dp[1][1] = to[1][1]; for (int i = 2; i &lt;= N; i++) &#123; dp[i][1] = to[i][1] + dp[i - 1][1]; dp[i][i] = to[i][i] + dp[i - 1][i - 1]; &#125; for (int i = 3; i &lt;= N; i++) &#123; for (int j = 2; j &lt;= i - 1; j++) &#123; dp[i][j] = to[i][j] + max(dp[i - 1][j - 1], dp[i - 1][j]); &#125; &#125; int maxs = 0; for (int j = 1; j &lt;= N; j++) &#123; if (dp[N][j] &gt; maxs) &#123; maxs = dp[N][j]; &#125; &#125; cout &lt;&lt; maxs &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Dynamic Programming</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hdu2032 杨辉三角]]></title>
    <url>%2F2018%2F09%2F23%2FHdu2032%2F</url>
    <content type="text"><![CDATA[Description还记得中学时候学过的杨辉三角吗？具体的定义这里不再描述，你可以参考以下的图形：11 11 2 11 3 3 11 4 6 4 11 5 10 10 5 1 Input输入数据包含多个测试实例，每个测试实例的输入只包含一个正整数n（1&lt;=n&lt;=30），表示将要输出的杨辉三角的层数。 Output对应于每一个输入，请输出相应层数的杨辉三角，每一层的整数之间用一个空格隔开，每一个杨辉三角后面加一个空行。 Sample Input12 3 Sample Output12345611 111 11 2 1 Analysis此题向来作为一道DP的概念引入题，所以不可避免的成为一道水题。此题可以打表，可以DP，普通的算的话绝对会TLE，这里使用DP做法。 观察可知，每个位置的值等于其上方的值加上其左上方的值，得递推关系式 1dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]; Code123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;int main()&#123; int dp[30][30] = &#123; 0 &#125;; int n; while (cin &gt;&gt; n) &#123; for (int i = 0; i &lt;= n - 1; i++) &#123; dp[i][0] = 1; dp[i][i] = 1; &#125; for (int i = 2; i &lt;= n - 1; i++) &#123; for (int j = 1; j &lt; i; j++) &#123; dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]; &#125; &#125; for (int i = 0; i &lt;= n - 1; i++) &#123; cout &lt;&lt; dp[i][0]; for (int j = 1; j &lt;= i; j++) &#123; cout &lt;&lt; " " &lt;&lt; dp[i][j]; &#125; cout &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Dynamic Programming</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hdu2612 Find a way]]></title>
    <url>%2F2018%2F09%2F22%2FHdu2612%2F</url>
    <content type="text"><![CDATA[DescriptionPass a year learning in Hangzhou, yifenfei arrival hometown Ningbo at finally. Leave Ningbo one year, yifenfei have many people to meet. Especially a good friend Merceki.Yifenfei’s home is at the countryside, but Merceki’s home is in the center of city. So yifenfei made arrangements with Merceki to meet at a KFC. There are many KFC in Ningbo, they want to choose one that let the total time to it be most smallest.Now give you a Ningbo map, Both yifenfei and Merceki can move up, down ,left, right to the adjacent road by cost 11 minutes. InputThe input contains multiple test cases.Each test case include, first two integers n, m. (2&lt;=n,m&lt;=200).Next n lines, each line included m character.‘Y’ express yifenfei initial position.‘M’ express Merceki initial position.‘#’ forbid road;‘.’ Road.‘@’ KFC OutputFor each test case output the minimum total time that both yifenfei and Merceki to arrival one of KFC.You may sure there is always have a KFC that can let them meet. Sample Input123456789101112131415164 4Y.#@.....#..@..M4 4Y.#@.....#..@#.M5 5Y..@..#....#...@..M.#...# Sample Output123668866 Analysis求一点到彼此所用时间之和最小，可以将y和m到每点的时间分别用BFS打表存储，然后扫到’@‘后计算，算出最小的一个时间。另外y和m不能经过互相的出发点，所以在他们分别BFS时，地图上对方需暂时变为‘#’。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;int dby[1000][1000];int dbm[1000][1000];bool visit[1000][1000];char map[1000][1000];struct node&#123; int n, m, t;&#125;;using namespace std;int main()&#123; int n, m; while (cin &gt;&gt; n &gt;&gt; m) &#123; int ans = 1000000; int yn, ym, mn, mm; memset(dby, 0, sizeof(dby)); memset(dbm, 0, sizeof(dbm)); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; map[i]; for (int j = 0; j &lt; m; j++) &#123; if (map[i][j] == 'Y') &#123; yn = i; ym = j; &#125; if (map[i][j] == 'M') &#123; mn = i; mm = j; &#125; &#125; &#125; memset(visit, 0, sizeof(visit)); node start; start.n = yn; start.m = ym; start.t = 0; visit[yn][ym] = 1; map[mn][mm] = '#'; queue&lt;node&gt; qy; qy.push(start); while (!qy.empty()) &#123; node fy = qy.front(); qy.pop(); dby[fy.n][fy.m] = fy.t; fy.t += 1; node vy = fy; if (vy.n - 1 &gt;= 0 &amp;&amp; visit[vy.n - 1][vy.m] == 0 &amp;&amp; map[vy.n - 1][vy.m] != '#') &#123; visit[vy.n - 1][vy.m] = 1; dby[vy.n - 1][vy.m] = vy.t; vy.n -= 1; qy.push(vy); &#125; vy = fy; if (vy.n + 1 &lt; n &amp;&amp; visit[vy.n + 1][vy.m] == 0 &amp;&amp; map[vy.n + 1][vy.m] != '#') &#123; visit[vy.n + 1][vy.m] = 1; dby[vy.n + 1][vy.m] = vy.t; vy.n += 1; qy.push(vy); &#125; vy = fy; if (vy.m - 1 &gt;= 0 &amp;&amp; visit[vy.n][vy.m - 1] == 0 &amp;&amp; map[vy.n][vy.m - 1] != '#') &#123; visit[vy.n][vy.m - 1] = 1; dby[vy.n][vy.m - 1] = vy.t; vy.m -= 1; qy.push(vy); &#125; vy = fy; if (vy.m + 1 &lt; m &amp;&amp; visit[vy.n][vy.m + 1] == 0 &amp;&amp; map[vy.n][vy.m + 1] != '#') &#123; visit[vy.n][vy.m + 1] = 1; dby[vy.n][vy.m + 1] = vy.t; vy.m += 1; qy.push(vy); &#125; &#125; map[mn][mm] = 'M'; memset(visit, 0, sizeof(visit)); start.n = mn; start.m = mm; start.t = 0; visit[mn][mm] = 1; map[yn][ym] = '#'; queue&lt;node&gt; qm; qm.push(start); while (!qm.empty()) &#123; node fm = qm.front(); qm.pop(); dbm[fm.n][fm.m] = fm.t; fm.t += 1; node vm = fm; if (vm.n - 1 &gt;= 0 &amp;&amp; visit[vm.n - 1][vm.m] == 0 &amp;&amp; map[vm.n - 1][vm.m] != '#') &#123; visit[vm.n - 1][vm.m] = 1; dbm[vm.n - 1][vm.m] = vm.t; vm.n -= 1; qm.push(vm); &#125; vm = fm; if (vm.n + 1 &lt; n &amp;&amp; visit[vm.n + 1][vm.m] == 0 &amp;&amp; map[vm.n + 1][vm.m] != '#') &#123; visit[vm.n + 1][vm.m] = 1; dbm[vm.n + 1][vm.m] = vm.t; vm.n += 1; qm.push(vm); &#125; vm = fm; if (vm.m - 1 &gt;= 0 &amp;&amp; visit[vm.n][vm.m - 1] == 0 &amp;&amp; map[vm.n][vm.m - 1] != '#') &#123; visit[vm.n][vm.m - 1] = 1; dbm[vm.n][vm.m - 1] = vm.t; vm.m -= 1; qm.push(vm); &#125; vm = fm; if (vm.m + 1 &lt; m &amp;&amp; visit[vm.n][vm.m + 1] == 0 &amp;&amp; map[vm.n][vm.m + 1] != '#') &#123; visit[vm.n][vm.m + 1] = 1; dbm[vm.n][vm.m + 1] = vm.t; vm.m += 1; qm.push(vm); &#125; &#125; map[yn][ym] = 'Y'; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (map[i][j] == '@'&amp;&amp;dby[i][j] != 0 &amp;&amp; dbm[i][j] != 0) &#123; ans = min(ans, dby[i][j] + dbm[i][j]); &#125; &#125; &#125; cout &lt;&lt; ans * 11 &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Search</category>
        <category>Breadth First Search</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>广搜</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Poj2251 Dungeon Master]]></title>
    <url>%2F2018%2F09%2F22%2FPoj2251%2F</url>
    <content type="text"><![CDATA[DescriptionYou are trapped in a 3D dungeon and need to find the quickest way out! The dungeon is composed of unit cubes which may or may not be filled with rock. It takes one minute to move one unit north, south, east, west, up or down. You cannot move diagonally and the maze is surrounded by solid rock on all sides. Is an escape possible? If yes, how long will it take? InputThe input consists of a number of dungeons. Each dungeon description starts with a line containing three integers L, R and C (all limited to 30 in size). L is the number of levels making up the dungeon. R and C are the number of rows and columns making up the plan of each level. Then there will follow L blocks of R lines each containing C characters. Each character describes one cell of the dungeon. A cell full of rock is indicated by a ‘#’ and empty cells are represented by a ‘.’. Your starting position is indicated by ‘S’ and the exit by the letter ‘E’. There’s a single blank line after each level. Input is terminated by three zeroes for L, R and C. OutputEach maze generates one line of output. If it is possible to reach the exit, print a line of the form Escaped in x minute(s). where x is replaced by the shortest time it takes to escape. If it is not possible to escape, print the line Trapped! Sample Input123456789101112131415161718192021223 4 5S.....###..##..###.#############.####...###########.#######E1 3 3S###E####0 0 0 Sample Output12Escaped in 11 minute(s).Trapped! AnalysisBFS裸题，从二维变成了三维的，其实也就是多了两个遍历方向，开三维数组写的时候注意一下就行了。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;char map[100][100][100];bool visit[100][100][100];int db[100][100][100];using namespace std;struct node&#123; int l, r, c; int t;&#125;;int sl, sr, sc;int el, er, ec;int main()&#123; int l, r, c; while (cin &gt;&gt; l &gt;&gt; r &gt;&gt; c) &#123; if (l == 0 &amp;&amp; r == 0 &amp;&amp; c == 0) break; int ans = 1000000; memset(db, 0, sizeof(db)); memset(visit, 0, sizeof(visit)); memset(map, '#', sizeof(map)); for (int i = 0; i &lt; l; i++) &#123; for (int j = 0; j &lt; r; j++) &#123; cin &gt;&gt; map[i][j]; for (int k = 0; k &lt; c; k++) &#123; if (map[i][j][k] == 'S') &#123; sl = i; sr = j; sc = k; &#125; if (map[i][j][k] == 'E') &#123; el = i; er = j; ec = k; &#125; &#125; &#125; &#125; node start; start.l = sl; start.r = sr; start.c = sc; start.t = 0; visit[sl][sr][sc] = 1; queue&lt;node&gt; q; q.push(start); while (!q.empty()) &#123; node f = q.front(); q.pop(); db[f.l][f.r][f.c] = f.t; f.t += 1; node v = f; if (v.l - 1 &gt;= 0 &amp;&amp; visit[v.l - 1][v.r][v.c] == 0 &amp;&amp; map[v.l - 1][v.r][v.c] != '#') &#123; visit[v.l - 1][v.r][v.c] = 1; db[v.l - 1][v.r][v.c] = v.t; v.l -= 1; q.push(v); &#125; v = f; if (v.l + 1 &lt; l &amp;&amp; visit[v.l + 1][v.r][v.c] == 0 &amp;&amp; map[v.l + 1][v.r][v.c] != '#') &#123; visit[v.l + 1][v.r][v.c] = 1; db[v.l + 1][v.r][v.c] = v.t; v.l += 1; q.push(v); &#125; v = f; if (v.r - 1 &gt;= 0 &amp;&amp; visit[v.l][v.r - 1][v.c] == 0 &amp;&amp; map[v.l][v.r - 1][v.c] != '#') &#123; visit[v.l][v.r - 1][v.c] = 1; db[v.l][v.r - 1][v.c] = v.t; v.r -= 1; q.push(v); &#125; v = f; if (v.r + 1 &lt; r &amp;&amp; visit[v.l][v.r + 1][v.c] == 0 &amp;&amp; map[v.l][v.r + 1][v.c] != '#') &#123; visit[v.l][v.r + 1][v.c] = 1; db[v.l][v.r + 1][v.c] = v.t; v.r += 1; q.push(v); &#125; v = f; if (v.c - 1 &gt;= 0 &amp;&amp; visit[v.l][v.r][v.c - 1] == 0 &amp;&amp; map[v.l][v.r][v.c - 1] != '#') &#123; visit[v.l][v.r][v.c - 1] = 1; db[v.l][v.r][v.c - 1] = v.t; v.c -= 1; q.push(v); &#125; v = f; if (v.c + 1 &lt; c &amp;&amp; visit[v.l][v.r][v.c + 1] == 0 &amp;&amp; map[v.l][v.r][v.c + 1] != '#') &#123; visit[v.l][v.r][v.c + 1] = 1; db[v.l][v.r][v.c + 1] = v.t; v.c += 1; q.push(v); &#125; &#125; for (int i = 0; i &lt; l; i++) &#123; for (int j = 0; j &lt; r; j++) &#123; for (int k = 0; k &lt; c; k++) &#123; if (map[i][j][k] == 'E') &#123; ans = min(ans, db[i][j][k]); &#125; &#125; &#125; &#125; if (ans == 0) &#123; cout &lt;&lt; "Trapped!" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "Escaped in " &lt;&lt; ans &lt;&lt; " minute(s)." &lt;&lt; endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Search</category>
        <category>Breadth First Search</category>
      </categories>
      <tags>
        <tag>广搜</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hdu1495 非常可乐]]></title>
    <url>%2F2018%2F09%2F20%2FHdu1495%2F</url>
    <content type="text"><![CDATA[Description大家一定觉得运动以后喝可乐是一件很惬意的事情，但是seeyou却不这么认为。因为每次当seeyou买了可乐以后，阿牛就要求和seeyou一起分享这一瓶可乐，而且一定要喝的和seeyou一样多。但seeyou的手中只有两个杯子，它们的容量分别是N 毫升和M 毫升 可乐的体积为S （S&lt;101）毫升 (正好装满一瓶) ，它们三个之间可以相互倒可乐 (都是没有刻度的，且 S==N+M，101＞S＞0，N＞0，M＞0) 。聪明的ACMER你们说他们能平分吗？如果能请输出倒可乐的最少的次数，如果不能输出”NO”。 Input三个整数 : S 可乐的体积 , N 和 M是两个杯子的容量，以”0 0 0”结束。 Output如果能平分的话请输出最少要倒的次数，否则输出”NO”。 Sample Input1237 4 34 1 30 0 0 Sample Output12NO3 Analysis此题可以数论，可以BFS，然而菜鸡我根本不会数论，所以在此记录BFS做法。因为容器没有刻度，所以每次倒只能将目标倒满或者将自己倒空，每次进行倒的操作，共有6种倒法，S-&gt;N，S-&gt;M，N-&gt;S，N-&gt;M，M-&gt;S，M-&gt;N，放进队列进行BFS即可，只需要记录倒的次数，并在最早达成条件时返回这个次数，即最少次数。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int s, n, m, s2;struct node&#123; int s, n, m, t;&#125;;int bfs()&#123; if (s % 2 == 1) return -1; queue&lt;node&gt; q; s2 = s / 2; bool vis[100][100][100] = &#123; false &#125;; node f; f.s = s; f.n = 0; f.m = 0; f.t = 0; q.push(f); vis[f.s][f.n][f.m] = true; while (!q.empty()) &#123; f = q.front(); q.pop(); if ((f.s == f.n&amp;&amp;f.s == s2) || (f.s == f.m&amp;&amp;f.s == s2) || (f.m == f.n&amp;&amp;f.m == s2)) return f.t; node v; //s--&gt;n if (f.s&amp;&amp;n - f.n &gt; 0) &#123; if (f.s &gt; n - f.n) &#123; v.s = f.s - (n - f.n); v.n = n; v.m = f.m; &#125; else &#123; v.s = 0; v.n = f.n + f.s; v.m = f.m; &#125; if (vis[v.s][v.n][v.m] == false) &#123; vis[v.s][v.n][v.m] = true; v.t = f.t + 1; q.push(v); &#125; &#125; //s--&gt;m if (f.s&amp;&amp;m - f.m &gt; 0) &#123; if (f.s &gt; m - f.m) &#123; v.s = f.s - (m - f.m); v.n = f.n; v.m = m; &#125; else &#123; v.s = 0; v.n = f.n; v.m = f.m + f.s; &#125; if (vis[v.s][v.n][v.m] == false) &#123; vis[v.s][v.n][v.m] = true; v.t = f.t + 1; q.push(v); &#125; &#125; //n--&gt;s if (f.n&amp;&amp;s - f.s &gt; 0) &#123; if (f.n &gt; s - f.s) &#123; v.s = s; v.n = f.n - (s - f.s); v.m = f.m; &#125; else &#123; v.s = f.s + f.n; v.n = 0; v.m = f.m; &#125; if (vis[v.s][v.n][v.m] == false) &#123; vis[v.s][v.n][v.m] = true; v.t = f.t + 1; q.push(v); &#125; &#125; //n--&gt;m if (f.n&amp;&amp;m - f.m &gt; 0) &#123; if (f.n &gt; m - f.m) &#123; v.s = f.s; v.n = f.n - (m - f.m); v.m = m; &#125; else &#123; v.s = f.s; v.n = 0; v.m = f.m + f.n; &#125; if (vis[v.s][v.n][v.m] == false) &#123; vis[v.s][v.n][v.m] = true; v.t = f.t + 1; q.push(v); &#125; &#125; //m--&gt;s if (f.m&amp;&amp;s - f.s &gt; 0) &#123; if (f.m &gt; s - f.s) &#123; v.s = s; v.n = f.n; v.m = f.m - (s - f.s); &#125; else &#123; v.s = f.s + f.m; v.n = f.n; v.m = 0; &#125; if (vis[v.s][v.n][v.m] == false) &#123; vis[v.s][v.n][v.m] = true; v.t = f.t + 1; q.push(v); &#125; &#125; //m--&gt;n if (f.m&amp;&amp;n - f.n &gt; 0) &#123; if (f.m &gt; n - f.n) &#123; v.s = f.s; v.n = n; v.m = f.m - (n - f.n); &#125; else &#123; v.s = f.s; v.n = f.n + f.m; v.m = 0; &#125; if (vis[v.s][v.n][v.m] == false) &#123; vis[v.s][v.n][v.m] = true; v.t = f.t + 1; q.push(v); &#125; &#125; &#125; return -1;&#125;int main()&#123; while (cin &gt;&gt; s &gt;&gt; n &gt;&gt; m) &#123; if (s == 0 &amp;&amp; n == 0 &amp;&amp; m == 0) break; int ans = bfs(); if (ans &lt; 0) cout &lt;&lt; "NO" &lt;&lt; endl; else cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Search</category>
        <category>Breadth First Search</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>广搜</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Poj1321 棋盘问题]]></title>
    <url>%2F2018%2F09%2F20%2FPoj1321%2F</url>
    <content type="text"><![CDATA[Description在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。 Input输入含有多组测试数据。 每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目。 n &lt;= 8 , k &lt;= n 当为-1 -1时表示输入结束。 随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。 Output对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C&lt;2^31）。 Sample Input1234567892 1#..#4 4...#..#..#..#...-1 -1 Sample Output1221 Analysis标准的DFS，可以逐行进行遍历搜索，当这一行已有棋子时就结束并消除标记，否则继续搜。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int n, k;char a[10][10];bool visit[10];int C, m;void dfs(int x)&#123; if (m == k) &#123; C += 1; return; &#125; if (x &gt;= n) return; for (int j = 0; j &lt; n; j++) &#123; if (visit[j] == 0 &amp;&amp; a[x][j] == '#') &#123; visit[j] = 1; m += 1; dfs(x + 1); visit[j] = 0; m -= 1; &#125; &#125; dfs(x + 1);&#125;int main()&#123; while (cin &gt;&gt; n &gt;&gt; k) &#123; if (n == -1 &amp;&amp; k == -1) break; C = 0; m = 0; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; memset(visit, 0, sizeof(visit)); dfs(0); cout &lt;&lt; C &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Search</category>
        <category>Depth First Search</category>
      </categories>
      <tags>
        <tag>深搜</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Poj1014 Dividing]]></title>
    <url>%2F2018%2F09%2F18%2FPoj1014%2F</url>
    <content type="text"><![CDATA[DescriptionMarsha and Bill own a collection of marbles. They want to split the collection among themselves so that both receive an equal share of the marbles. This would be easy if all the marbles had the same value, because then they could just split the collection in half. But unfortunately, some of the marbles are larger, or more beautiful than others. So, Marsha and Bill start by assigning a value, a natural number between one and six, to each marble. Now they want to divide the marbles so that each of them gets the same total value. Unfortunately, they realize that it might be impossible to divide the marbles in this way (even if the total value of all marbles is even). For example, if there are one marble of value 1, one of value 3 and two of value 4, then they cannot be split into sets of equal value. So, they ask you to write a program that checks whether there is a fair partition of the marbles. InputEach line in the input file describes one collection of marbles to be divided. The lines contain six non-negative integers n1 , . . . , n6 , where ni is the number of marbles of value i. So, the example from above would be described by the input-line “1 0 1 2 0 0”. The maximum total number of marbles will be 20000. The last line of the input file will be “0 0 0 0 0 0”; do not process this line. OutputFor each collection, output “Collection #k:”, where k is the number of the test case, and then either “Can be divided.” or “Can’t be divided.”. Output a blank line after each test case. Sample Input1231 0 1 2 0 0 1 0 0 0 1 1 0 0 0 0 0 0 Sample Output12345Collection #1:Can&apos;t be divided.Collection #2:Can be divided. Analysis此题可背包，可DFS，这里使用DFS做法。 每次探测六种选择，进行一次选择后数量减一同时递归，若在递归过程中存在一次结果为总价值的一半，则DFS结束，否则不能平分。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;using namespace std;int num[7];int Case;int sum;int half;int flag;void dfs(int value, int pre)&#123; if (flag) return; if (value == half) &#123; flag = true; return; &#125; for (int i = pre; i &gt;= 1; i--) &#123; if (num[i]) &#123; if (value + i &lt;= half) &#123; num[i]--; dfs(value + i, i); if (flag) break; &#125; &#125; &#125; return;&#125;int main()&#123; Case = 1; while (cin &gt;&gt; num[1] &gt;&gt; num[2] &gt;&gt; num[3] &gt;&gt; num[4] &gt;&gt; num[5] &gt;&gt; num[6]) &#123; sum = 0; for (int i = 1; i &lt;= 6; i++) &#123; sum += i * num[i]; &#125; if (sum == 0) break; half = sum / 2; flag = false; dfs(0, 6); if (sum % 2 || !flag) &#123; cout &lt;&lt; "Collection #" &lt;&lt; Case &lt;&lt; ":" &lt;&lt; endl; cout &lt;&lt; "Can't be divided." &lt;&lt; endl &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "Collection #" &lt;&lt; Case &lt;&lt; ":" &lt;&lt; endl; cout &lt;&lt; "Can be divided." &lt;&lt; endl &lt;&lt; endl; &#125; Case++; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Search</category>
        <category>Depth First Search</category>
      </categories>
      <tags>
        <tag>深搜</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Poj2386 Lake Counting]]></title>
    <url>%2F2018%2F09%2F16%2FPoj2386%2F</url>
    <content type="text"><![CDATA[DescriptionDue to recent rains, water has pooled in various places in Farmer John’s field, which is represented by a rectangle of N x M (1 &lt;= N &lt;= 100; 1 &lt;= M &lt;= 100) squares. Each square contains either water (‘W’) or dry land (‘.’). Farmer John would like to figure out how many ponds have formed in his field. A pond is a connected set of squares with water in them, where a square is considered adjacent to all eight of its neighbors. Given a diagram of Farmer John’s field, determine how many ponds he has. Input* Line 1: Two space-separated integers: N and M * Lines 2..N+1: M characters per line representing one row of Farmer John’s field. Each character is either ‘W’ or ‘.’. The characters do not have spaces between them. Output* Line 1: The number of ponds in Farmer John’s field. Sample Input123456789101110 12W........WW..WWW.....WWW....WW...WW..........WW..........W....W......W...W.W.....WW.W.W.W.....W..W.W......W...W.......W. Sample Output13 AnalysisDFS板题，从任意的w开始，不断把邻接的部分用.代替，1次DFS后与初始这个w连接的所有w就全都被替换成.，因此直到图中不再存在w为止，总共进行的DFS次数就是答案。8个方向对应8个状态转移，每个格子作为DFS的参数最多调用一次，时间复杂度为O(8nm)=O(nm)。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;using namespace std;int N, M;char field[100][100];void dfs(int x, int y)&#123; field[x][y] = '.'; for (int dx = -1; dx &lt;= 1; dx++) &#123; for (int dy = -1; dy &lt;= 1; dy++) &#123; int nx = x + dx; int ny = y + dy; if (0 &lt;= nx &amp;&amp; nx &lt; N &amp;&amp; 0 &lt;= ny &amp;&amp; ny &lt; M&amp;&amp;field[nx][ny] == 'W') dfs(nx, ny); &#125; &#125; return;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; M; for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; M; j++) &#123; cin &gt;&gt; field[i][j]; &#125; &#125; int res = 0; for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; M; j++) &#123; if (field[i][j] == 'W') &#123; dfs(i, j); res++; &#125; &#125; &#125; cout &lt;&lt; res &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Search</category>
        <category>Depth First Search</category>
      </categories>
      <tags>
        <tag>深搜</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hdu1241 Oil Deposits]]></title>
    <url>%2F2018%2F09%2F16%2FHdu1241%2F</url>
    <content type="text"><![CDATA[DescriptionThe GeoSurvComp geologic survey company is responsible for detecting underground oil deposits. GeoSurvComp works with one large rectangular region of land at a time, and creates a grid that divides the land into numerous square plots. It then analyzes each plot separately, using sensing equipment to determine whether or not the plot contains oil. A plot containing oil is called a pocket. If two pockets are adjacent, then they are part of the same oil deposit. Oil deposits can be quite large and may contain numerous pockets. Your job is to determine how many different oil deposits are contained in a grid. InputThe input file contains one or more grids. Each grid begins with a line containing m and n, the number of rows and columns in the grid, separated by a single space. If m = 0 it signals the end of the input; otherwise 1 &lt;= m &lt;= 100 and 1 &lt;= n &lt;= 100. Following this are m lines of n characters each (not counting the end-of-line characters). Each character corresponds to one plot, and is either ‘*’, representing the absence of oil, or ‘@’, representing an oil pocket. OutputFor each grid, output the number of distinct oil deposits. Two different pockets are part of the same oil deposit if they are adjacent horizontally, vertically, or diagonally. An oil deposit will not contain more than 100 pockets. Sample Input1234567891011121314151 1*3 5*@*@***@***@*@*1 8@@****@*5 5 ****@*@@*@*@**@@@@*@@@**@0 0 Sample Output12340122 AnalysisDFS板题，求连通区域的数量，从任意一点开始，将遇到的@变成*并从此点开始进行DFS，DFS过程中遇到@进行相同操作后递归，一次DFS完成后会将一个连通区域中的@全部变成*，这样总共进行的DFS次数就是连通区域的个数。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;using namespace std;char field[100][100];int m, n;void dfs(int x, int y)&#123; field[x][y] = '*'; for (int dx = -1; dx &lt;= 1; dx++) &#123; for (int dy = -1; dy &lt;= 1; dy++) &#123; int nx = x + dx; int ny = y + dy; if (0 &lt;= nx &amp;&amp; nx &lt; m &amp;&amp; 0 &lt;= ny &amp;&amp; ny &lt; n&amp;&amp;field[nx][ny] == '@') &#123; dfs(nx, ny); &#125; &#125; &#125; return;&#125;int main()&#123; while (cin &gt;&gt; m &gt;&gt; n) &#123; if (m == 0) break; int res = 0; field[100][100] = &#123; 0 &#125;; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; cin &gt;&gt; field[i][j]; &#125; &#125; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (field[i][j] == '@') &#123; dfs(i, j); res++; &#125; &#125; &#125; cout &lt;&lt; res &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Search</category>
        <category>Depth First Search</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>深搜</tag>
      </tags>
  </entry>
</search>
